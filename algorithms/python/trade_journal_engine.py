"""Dynamic multi-LLM trade journaling workflow."""

from __future__ import annotations

import json
import textwrap
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, Mapping, Optional, Sequence

from .multi_llm import LLMConfig, LLMRun, collect_strings, parse_json_response, serialise_runs


@dataclass(slots=True)
class TradeRecord:
    """Represents an executed trade and its qualitative notes."""

    symbol: str
    direction: str
    entry_price: float
    exit_price: float
    size: float
    pnl: float
    reward_risk: Optional[float] = None
    setup: Optional[str] = None
    grade: Optional[str] = None
    notes: str = ""
    tags: Sequence[str] = field(default_factory=tuple)
    checklist_misses: Sequence[str] = field(default_factory=tuple)

    def to_prompt_payload(self) -> Dict[str, Any]:
        payload: Dict[str, Any] = {
            "symbol": self.symbol,
            "direction": self.direction,
            "entry_price": self.entry_price,
            "exit_price": self.exit_price,
            "size": self.size,
            "pnl": self.pnl,
        }
        if self.reward_risk is not None:
            payload["reward_risk"] = self.reward_risk
        if self.setup:
            payload["setup"] = self.setup
        if self.grade:
            payload["grade"] = self.grade
        if self.notes:
            payload["notes"] = self.notes
        if self.tags:
            payload["tags"] = list(self.tags)
        if self.checklist_misses:
            payload["checklist_misses"] = list(self.checklist_misses)
        return payload


@dataclass(slots=True)
class TradeJournalRequest:
    """Input payload describing a trading session."""

    session_date: str
    session_summary: str
    objectives: Sequence[str]
    market_context: str
    trades: Sequence[TradeRecord]
    risk_events: Sequence[str] = field(default_factory=tuple)
    mindset_notes: Sequence[str] = field(default_factory=tuple)
    metrics: Mapping[str, Any] = field(default_factory=dict)
    environment: Mapping[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class TradeJournalReport:
    """Final artefact generated by :class:`TradeJournalEngine`."""

    summary: str
    performance_highlights: list[str]
    lessons: list[str]
    next_actions: list[str]
    mindset_reflections: list[str]
    coach_prompts: list[str]
    metadata: Dict[str, Any]
    runs: Sequence[LLMRun]
    raw_response: Optional[str]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "summary": self.summary,
            "performance_highlights": list(self.performance_highlights),
            "lessons": list(self.lessons),
            "next_actions": list(self.next_actions),
            "mindset_reflections": list(self.mindset_reflections),
            "coach_prompts": list(self.coach_prompts),
            "metadata": dict(self.metadata),
            "raw_response": self.raw_response,
        }


@dataclass(slots=True)
class TradeJournalEngine:
    """Coordinates specialised LLMs to compile a trade journal."""

    analysis: LLMConfig
    insight: LLMConfig
    coach: Optional[LLMConfig] = None
    max_trades: int = 12
    max_objectives: int = 6
    max_risk_events: int = 6

    def generate(self, request: TradeJournalRequest) -> TradeJournalReport:
        """Return a structured journal entry for the supplied session."""

        runs: list[LLMRun] = []
        metadata: Dict[str, Any] = {
            "session_date": request.session_date,
            "objective_count": len(request.objectives),
            "risk_event_count": len(request.risk_events),
            "trade_count": len(request.trades),
            "metrics": dict(request.metrics),
            "environment": dict(request.environment),
        }

        focus_trades = list(request.trades[: self.max_trades])
        metadata["trades_in_prompt"] = [trade.to_prompt_payload() for trade in focus_trades]

        analysis_prompt = self._build_analysis_prompt(request, focus_trades)
        analysis_run = self.analysis.run(analysis_prompt)
        runs.append(analysis_run)
        analysis_payload = parse_json_response(analysis_run.response, fallback_key="summary") or {}
        metadata["analysis_payload"] = analysis_payload

        insight_prompt = self._build_insight_prompt(request, analysis_payload)
        insight_run = self.insight.run(insight_prompt)
        runs.append(insight_run)
        insight_payload = parse_json_response(insight_run.response, fallback_key="insight") or {}
        metadata["insight_payload"] = insight_payload

        coach_payload: Dict[str, Any] = {}
        if self.coach:
            coach_prompt = self._build_coach_prompt(request, analysis_payload, insight_payload)
            coach_run = self.coach.run(coach_prompt)
            runs.append(coach_run)
            coach_payload = parse_json_response(coach_run.response, fallback_key="coaching") or {}
            metadata["coach_payload"] = coach_payload

        summary = self._resolve_summary(request, analysis_payload, coach_payload)
        highlights = collect_strings(
            analysis_payload.get("highlights"),
            analysis_payload.get("performance_highlights"),
            analysis_payload.get("callouts"),
            insight_payload.get("highlights"),
        )
        lessons = collect_strings(
            analysis_payload.get("lessons"),
            insight_payload.get("lessons"),
            insight_payload.get("breakdowns"),
        )
        next_actions = collect_strings(
            insight_payload.get("adjustments"),
            insight_payload.get("next_actions"),
            coach_payload.get("next_actions"),
        )
        mindset_reflections = collect_strings(
            analysis_payload.get("mindset"),
            analysis_payload.get("mindset_notes"),
            request.mindset_notes,
            coach_payload.get("affirmations"),
            coach_payload.get("mindset"),
        )
        coach_prompts = collect_strings(
            insight_payload.get("reflection_prompts"),
            coach_payload.get("prompts"),
            coach_payload.get("questions"),
        )

        raw_response = serialise_runs(runs)
        report_metadata = {
            **metadata,
            "analysis_summary": summary,
            "next_actions_count": len(next_actions),
        }

        return TradeJournalReport(
            summary=summary,
            performance_highlights=list(highlights),
            lessons=list(lessons),
            next_actions=list(next_actions),
            mindset_reflections=list(mindset_reflections),
            coach_prompts=list(coach_prompts),
            metadata=report_metadata,
            runs=runs,
            raw_response=raw_response,
        )

    def _build_analysis_prompt(
        self,
        request: TradeJournalRequest,
        trades: Sequence[TradeRecord],
    ) -> str:
        objectives = self._format_bullets(request.objectives[: self.max_objectives])
        risk_events = self._format_bullets(request.risk_events[: self.max_risk_events])
        mindset = self._format_bullets(request.mindset_notes)
        trades_json = json.dumps(
            [trade.to_prompt_payload() for trade in trades],
            indent=2,
            default=str,
            sort_keys=True,
        )
        metrics_json = json.dumps(request.metrics, indent=2, default=str, sort_keys=True)
        environment_json = json.dumps(request.environment, indent=2, default=str, sort_keys=True)

        return textwrap.dedent(
            f"""
            You are the Dynamic Capital trade journal analyst coordinating a multi-model workflow.
            Review the trading session and return a minified JSON object with the following keys:
              - "summary": concise 2-3 sentence recap of the session quality.
              - "highlights": array of positive observations tied to risk or execution.
              - "lessons": array of improvements or deviations from plan.
              - "mindset_notes": optional array capturing emotional state or psychology signals.
              - "metrics": optional object echoing or extending provided metrics.
              - "callouts": optional array of items to escalate to the coach model.
            Do not include markdown or commentary outside JSON.

            Session date: {request.session_date}
            Session summary: {request.session_summary}

            Objectives:
            {objectives}

            Market context:
            {request.market_context}

            Risk events:
            {risk_events}

            Mindset notes:
            {mindset}

            Metrics provided by desk:
            {metrics_json}

            Trading environment snapshot:
            {environment_json}

            Executed trades (showing up to {len(trades)} of {len(request.trades)} total):
            {trades_json}
            """
        ).strip()

    def _build_insight_prompt(
        self,
        request: TradeJournalRequest,
        analysis_payload: Mapping[str, Any],
    ) -> str:
        objectives = self._format_bullets(request.objectives[: self.max_objectives])
        analysis_json = json.dumps(analysis_payload, indent=2, default=str, sort_keys=True)
        return textwrap.dedent(
            f"""
            You are the Dynamic Capital execution quality auditor operating after the analyst model.
            Cross-reference the analyst findings with the trading objectives and propose concrete adjustments.
            Respond with a compact JSON object containing:
              - "adjustments": array of specific process tweaks or drills for the next session.
              - "next_actions": array of checklist-ready tasks for the trader.
              - "lessons": optional array reinforcing critical takeaways.
              - "reflection_prompts": optional questions for deeper journaling.
            Avoid markdown and keep responses focused on actionability.

            Trading objectives:
            {objectives}

            Analyst findings:
            {analysis_json}
            """
        ).strip()

    def _build_coach_prompt(
        self,
        request: TradeJournalRequest,
        analysis_payload: Mapping[str, Any],
        insight_payload: Mapping[str, Any],
    ) -> str:
        analysis_json = json.dumps(analysis_payload, indent=2, default=str, sort_keys=True)
        insight_json = json.dumps(insight_payload, indent=2, default=str, sort_keys=True)
        return textwrap.dedent(
            f"""
            You are the Dynamic Capital trading coach focused on psychology and habit reinforcement.
            Ingest the analyst assessment and the execution auditor's recommendations.
            Return a JSON object with:
              - "prompts": reflective questions to explore in the journal.
              - "affirmations": supportive statements acknowledging what went well.
              - "next_actions": optional behavioural commitments to review later.
              - "mindset": optional array of mental models or cues to anchor before the next session.
            Keep it under 120 tokens and do not include markdown.

            Analyst assessment:
            {analysis_json}

            Execution adjustments:
            {insight_json}
            """
        ).strip()

    @staticmethod
    def _format_bullets(items: Iterable[Any]) -> str:
        values = [str(item).strip() for item in items if str(item).strip()]
        if not values:
            return "- None"
        return "\n".join(f"- {value}" for value in values)

    @staticmethod
    def _resolve_summary(
        request: TradeJournalRequest,
        analysis_payload: Mapping[str, Any],
        coach_payload: Mapping[str, Any],
    ) -> str:
        summary = analysis_payload.get("summary") if isinstance(analysis_payload, Mapping) else None
        if isinstance(coach_payload, Mapping):
            coach_summary = coach_payload.get("summary") or coach_payload.get("headline")
            if isinstance(coach_summary, str) and coach_summary.strip():
                summary = coach_summary.strip()
        if isinstance(summary, str) and summary.strip():
            return summary.strip()
        return request.session_summary.strip()


__all__ = [
    "TradeRecord",
    "TradeJournalRequest",
    "TradeJournalReport",
    "TradeJournalEngine",
]
