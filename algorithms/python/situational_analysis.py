"""Situational analysis engine combining market telemetry and positioning."""

from __future__ import annotations

import math
from dataclasses import dataclass, field
from typing import Any, Dict, List, Mapping, Sequence

from .trade_logic import ActivePosition, MarketSnapshot

__all__ = [
    "SituationalAnalysisRequest",
    "SituationalAnalysisReport",
    "SituationalAnalysisEngine",
]


def _clamp(value: float, low: float = 0.0, high: float = 1.0) -> float:
    return max(low, min(high, value))


def _average_sentiment(sentiment: Mapping[str, float] | None) -> float:
    if not sentiment:
        return 0.0
    values = [score for score in sentiment.values() if math.isfinite(score)]
    if not values:
        return 0.0
    return sum(values) / len(values)


@dataclass(slots=True)
class SituationalAnalysisRequest:
    """Input payload required to derive situational market insights."""

    snapshot: MarketSnapshot
    open_positions: Sequence[ActivePosition] = field(default_factory=tuple)
    news_sentiment: Mapping[str, float] = field(default_factory=dict)
    catalysts: Sequence[str] = field(default_factory=tuple)
    risk_events: Sequence[str] = field(default_factory=tuple)
    discretionary_notes: Sequence[str] = field(default_factory=tuple)
    analytics: Mapping[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class SituationalAnalysisReport:
    """Structured situational analysis generated by the engine."""

    symbol: str
    bias: str
    posture: str
    bias_score: float
    confidence: float
    risk_score: float
    opportunity_score: float
    stress_level: float
    narrative: str
    drivers: List[str]
    flags: List[str]
    telemetry: Dict[str, Any]


@dataclass(slots=True)
class SituationalAnalysisEngine:
    """Scores market state, positioning, and catalysts to frame posture."""

    bullish_threshold: float = 0.35
    bearish_threshold: float = -0.35
    offensive_risk_ceiling: float = 0.55
    offensive_stress_ceiling: float = 0.65
    defensive_risk_floor: float = 0.75
    defensive_stress_floor: float = 0.75
    correlation_alert_threshold: float = 0.75
    stress_reference: float = 3.0

    def analyse(self, request: SituationalAnalysisRequest) -> SituationalAnalysisReport:
        """Return a situational assessment for the supplied request."""

        snapshot = request.snapshot
        sentiment_avg = _average_sentiment(request.news_sentiment)
        bias_score = self._bias_score(snapshot, sentiment_avg)
        stress_level = self._stress_level(snapshot)
        risk_score = self._risk_score(snapshot, request, bias_score, sentiment_avg, stress_level)
        opportunity_score = self._opportunity_score(
            bias_score, sentiment_avg, stress_level, risk_score, len(request.catalysts)
        )
        confidence = self._confidence(snapshot, bias_score, sentiment_avg, stress_level)
        bias = self._bias_from_score(bias_score)
        posture = self._posture(bias_score, risk_score, stress_level)
        drivers = self._drivers(snapshot, bias_score, sentiment_avg, opportunity_score)
        flags = self._flags(
            snapshot,
            request,
            bias_score,
            risk_score,
            stress_level,
            sentiment_avg,
        )
        narrative = self._narrative(snapshot.symbol, posture, bias_score, confidence, risk_score)

        telemetry: Dict[str, Any] = {
            "bias_score": round(bias_score, 4),
            "confidence": round(confidence, 4),
            "risk_score": round(risk_score, 4),
            "opportunity_score": round(opportunity_score, 4),
            "stress_level": round(stress_level, 4),
            "trend_strength": max(snapshot.adx_fast, snapshot.adx_slow),
            "news_sentiment_avg": round(sentiment_avg, 4),
            "open_positions": len(request.open_positions),
            "catalyst_count": len(request.catalysts),
            "risk_event_count": len(request.risk_events),
        }

        return SituationalAnalysisReport(
            symbol=snapshot.symbol,
            bias=bias,
            posture=posture,
            bias_score=bias_score,
            confidence=confidence,
            risk_score=risk_score,
            opportunity_score=opportunity_score,
            stress_level=stress_level,
            narrative=narrative,
            drivers=drivers,
            flags=flags,
            telemetry=telemetry,
        )

    # ------------------------------------------------------------------
    # Core scorers
    # ------------------------------------------------------------------

    def _bias_score(self, snapshot: MarketSnapshot, sentiment_avg: float) -> float:
        score = 0.0
        score += (snapshot.rsi_fast - 50.0) / 14.0
        score += (snapshot.rsi_slow - 50.0) / 18.0
        score += 0.35 * snapshot.mechanical_bias()
        score += 0.2 * math.tanh(max(snapshot.adx_fast, snapshot.adx_slow) / 45.0)
        if snapshot.seasonal_bias is not None and snapshot.seasonal_confidence:
            score += 0.25 * snapshot.seasonal_bias * snapshot.seasonal_confidence
        score += 0.25 * sentiment_avg
        return max(-2.0, min(2.0, score))

    def _stress_level(self, snapshot: MarketSnapshot) -> float:
        stress_ratio = float(snapshot.mechanical_stress_ratio or 0.0)
        return _clamp(stress_ratio / self.stress_reference)

    def _risk_score(
        self,
        snapshot: MarketSnapshot,
        request: SituationalAnalysisRequest,
        bias_score: float,
        sentiment_avg: float,
        stress_level: float,
    ) -> float:
        gross = sum(abs(position.size) for position in request.open_positions)
        net = sum(position.size * position.direction for position in request.open_positions)
        exposure_risk = 0.0
        if gross:
            alignment = abs(net) / gross if gross else 0.0
            misalignment = 0.0
            if bias_score > 0 and net < 0:
                misalignment = abs(net) / gross
            elif bias_score < 0 and net > 0:
                misalignment = abs(net) / gross
            exposure_scale = min(1.0, gross / (gross + 4.0))
            exposure_risk = exposure_scale * (0.7 * misalignment + 0.3 * alignment)

        sentiment_risk = max(0.0, -sentiment_avg)
        event_risk = min(0.35, 0.12 * len(request.risk_events))

        correlations = snapshot.correlation_scores or {}
        correlation_risk = 0.0
        if correlations:
            correlation_risk = max(0.0, max(abs(score) for score in correlations.values()) - 0.5)

        risk = 0.38 * stress_level
        risk += 0.27 * exposure_risk
        risk += 0.2 * sentiment_risk
        risk += 0.1 * correlation_risk
        risk += 0.1 * event_risk
        return _clamp(risk)

    def _opportunity_score(
        self,
        bias_score: float,
        sentiment_avg: float,
        stress_level: float,
        risk_score: float,
        catalyst_count: int,
    ) -> float:
        directional_edge = max(0.0, bias_score) / 1.5
        sentiment_boost = max(0.0, sentiment_avg) * 0.35
        catalyst_boost = min(0.3, 0.08 * catalyst_count)
        stress_penalty = 0.4 * stress_level
        risk_penalty = 0.45 * risk_score
        raw = 0.35 + directional_edge + sentiment_boost + catalyst_boost - stress_penalty - risk_penalty
        return _clamp(raw)

    def _confidence(
        self,
        snapshot: MarketSnapshot,
        bias_score: float,
        sentiment_avg: float,
        stress_level: float,
    ) -> float:
        trend_strength = max(snapshot.adx_fast, snapshot.adx_slow)
        trend_factor = _clamp(trend_strength / 50.0)
        bias_factor = _clamp(abs(bias_score) / 1.5)
        sentiment_factor = _clamp((sentiment_avg + 1.0) / 2.0)
        stability = 1.0 - 0.6 * stress_level
        raw = 0.25 + 0.35 * trend_factor + 0.2 * bias_factor + 0.12 * sentiment_factor + 0.08 * stability
        return _clamp(raw)

    # ------------------------------------------------------------------
    # Narrative helpers
    # ------------------------------------------------------------------

    def _bias_from_score(self, score: float) -> str:
        if score >= self.bullish_threshold:
            return "Bullish"
        if score <= self.bearish_threshold:
            return "Bearish"
        return "Neutral"

    def _posture(self, bias_score: float, risk_score: float, stress_level: float) -> str:
        if (
            bias_score >= self.bullish_threshold
            and risk_score <= self.offensive_risk_ceiling
            and stress_level <= self.offensive_stress_ceiling
        ):
            return "Offensive"
        if (
            bias_score <= self.bearish_threshold
            or risk_score >= self.defensive_risk_floor
            or stress_level >= self.defensive_stress_floor
        ):
            return "Defensive"
        return "Balanced"

    def _drivers(
        self,
        snapshot: MarketSnapshot,
        bias_score: float,
        sentiment_avg: float,
        opportunity_score: float,
    ) -> List[str]:
        drivers = [
            f"RSI blend points to {('bullish' if bias_score > 0 else 'bearish' if bias_score < 0 else 'neutral')} pressure (fast={snapshot.rsi_fast:.1f}, slow={snapshot.rsi_slow:.1f}).",
            f"Trend strength (ADX max {max(snapshot.adx_fast, snapshot.adx_slow):.1f}) supports the read.",
        ]
        if snapshot.mechanical_state:
            drivers.append(
                f"Mechanical state registered as {snapshot.mechanical_state} with bias {snapshot.mechanical_bias():.2f}."
            )
        if sentiment_avg:
            polarity = "supportive" if sentiment_avg > 0 else "adverse"
            drivers.append(f"News sentiment {polarity} at {sentiment_avg:.2f}.")
        drivers.append(f"Opportunity score resolved at {opportunity_score:.2f} after stress/risk adjustments.")
        return drivers

    def _flags(
        self,
        snapshot: MarketSnapshot,
        request: SituationalAnalysisRequest,
        bias_score: float,
        risk_score: float,
        stress_level: float,
        sentiment_avg: float,
    ) -> List[str]:
        flags: List[str] = []
        if risk_score >= self.defensive_risk_floor:
            flags.append(
                f"Risk score at {risk_score:.2f} demands defensive posture."
            )
        if stress_level >= self.defensive_stress_floor:
            flags.append(
                f"Mechanical stress elevated ({float(snapshot.mechanical_stress_ratio or 0.0):.2f})."
            )
        correlations = snapshot.correlation_scores or {}
        for symbol, score in correlations.items():
            if abs(score) >= self.correlation_alert_threshold:
                direction = "aligned" if (bias_score >= 0 and score > 0) or (bias_score < 0 and score < 0) else "divergent"
                flags.append(
                    f"{symbol} correlation {direction} at {score:.2f}."
                )
        if sentiment_avg <= -0.4:
            flags.append(f"News flow remains adverse ({sentiment_avg:.2f}).")
        if request.open_positions:
            gross = sum(abs(position.size) for position in request.open_positions)
            net = sum(position.size * position.direction for position in request.open_positions)
            if gross:
                net_ratio = net / gross
                if bias_score > 0 and net_ratio < -0.25:
                    flags.append(
                        "Net positioning opposes bullish bias; consider trimming shorts."
                    )
                if bias_score < 0 and net_ratio > 0.25:
                    flags.append(
                        "Net positioning opposes bearish bias; evaluate long risk."
                    )
        return flags

    def _narrative(
        self,
        symbol: str,
        posture: str,
        bias_score: float,
        confidence: float,
        risk_score: float,
    ) -> str:
        bias_direction = "bullish" if bias_score > 0 else "bearish" if bias_score < 0 else "balanced"
        return (
            f"{symbol} posture is {posture.lower()} with a {bias_direction} tilt (bias {bias_score:.2f}). "
            f"Confidence sits at {confidence:.2f} while risk measures {risk_score:.2f}."
        )

