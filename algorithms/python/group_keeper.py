"""Community group keeper orchestration for Dynamic Capital."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Dict, Iterable, Mapping, MutableMapping, Optional, Sequence, Tuple

from .multi_llm import LLMConfig, LLMRun, parse_json_response

__all__ = [
    "CommunityGroup",
    "GroupKeeperSyncResult",
    "DynamicGroupKeeperAlgorithm",
]


def _normalise_tuple(values: Iterable[Any]) -> Tuple[str, ...]:
    """Return a tuple of unique, stripped string values preserving order."""

    seen: set[str] = set()
    items: list[str] = []
    for value in values or ():
        text = str(value).strip()
        if not text or text in seen:
            continue
        seen.add(text)
        items.append(text)
    return tuple(items)


@dataclass(slots=True, frozen=True)
class CommunityGroup:
    """Represents a community group managed by the keeper."""

    name: str
    platform: str
    owners: Tuple[str, ...] = ()
    purpose: str = ""
    status: str = "active"
    region: str = ""
    tags: Tuple[str, ...] = ()
    managers: Tuple[str, ...] = ()
    channels: Tuple[str, ...] = ()
    member_count: int = 0
    cadence: str = ""
    priority: int = 0
    metadata: Mapping[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        name = self.name.strip()
        platform = self.platform.strip()
        if not name:
            raise ValueError("community group name is required")
        if not platform:
            raise ValueError("community group platform is required")
        object.__setattr__(self, "name", name)
        object.__setattr__(self, "platform", platform)
        object.__setattr__(self, "purpose", self.purpose.strip())
        object.__setattr__(self, "status", (self.status or "active").strip() or "active")
        object.__setattr__(self, "region", self.region.strip())
        object.__setattr__(self, "cadence", self.cadence.strip())
        object.__setattr__(self, "owners", _normalise_tuple(self.owners))
        object.__setattr__(self, "tags", _normalise_tuple(self.tags))
        object.__setattr__(self, "managers", _normalise_tuple(self.managers))
        object.__setattr__(self, "channels", _normalise_tuple(self.channels))
        object.__setattr__(self, "member_count", max(0, int(self.member_count)))
        object.__setattr__(self, "metadata", dict(self.metadata or {}))


@dataclass(slots=True)
class GroupKeeperSyncResult:
    """Structured payload generated by :class:`DynamicGroupKeeperAlgorithm`."""

    timestamp: datetime
    theme: Optional[str]
    groups: Sequence[MutableMapping[str, Any]]
    rituals: Sequence[MutableMapping[str, Any]]
    escalations: Sequence[MutableMapping[str, Any]]
    metrics: Mapping[str, Any]
    llm_runs: Tuple[LLMRun, ...] = ()
    metadata: Mapping[str, Any] = field(default_factory=dict)

    def summary(self) -> str:
        """Return a concise description of the sync."""

        parts = [f"{len(self.groups)} groups"]
        if self.rituals:
            parts.append(f"{len(self.rituals)} rituals")
        if self.escalations:
            parts.append(f"{len(self.escalations)} escalations")
        if self.theme:
            parts.append(f"theme '{self.theme}'")
        return ", ".join(parts)

    def to_dict(self) -> Dict[str, Any]:
        """Return a serialisable representation of the sync result."""

        payload: Dict[str, Any] = {
            "timestamp": self.timestamp.isoformat(),
            "theme": self.theme,
            "groups": [dict(group) for group in self.groups],
            "rituals": [dict(ritual) for ritual in self.rituals],
            "escalations": [dict(incident) for incident in self.escalations],
            "metrics": dict(self.metrics),
            "summary": self.summary(),
        }
        if self.llm_runs:
            payload["llm_runs"] = [run.to_dict(include_prompt=False) for run in self.llm_runs]
        if self.metadata:
            payload["metadata"] = dict(self.metadata)
        return payload


class DynamicGroupKeeperAlgorithm:
    """Coordinates Dynamic Capital community groups and rituals."""

    def __init__(self) -> None:
        self._groups: list[CommunityGroup] = []
        self._rituals: Dict[str, list[Mapping[str, Any]]] = {}
        self._escalations: Dict[str, list[Mapping[str, Any]]] = {}

    def register_group(self, group: CommunityGroup) -> None:
        """Register a persistent community group managed by the keeper."""

        self._groups.append(group)

    def register_ritual(self, group: str, ritual: Mapping[str, Any]) -> None:
        """Register a repeating ritual for a community group."""

        name = group.strip()
        if not name:
            raise ValueError("group identifier is required for ritual registration")
        self._rituals.setdefault(name, []).append(dict(ritual or {}))

    def register_escalation(self, group: str, details: Mapping[str, Any]) -> None:
        """Register an escalation or follow-up task for a community group."""

        name = group.strip()
        if not name:
            raise ValueError("group identifier is required for escalation registration")
        self._escalations.setdefault(name, []).append(dict(details or {}))

    def sync(
        self,
        *,
        as_of: Optional[datetime] = None,
        groups: Optional[Iterable[CommunityGroup]] = None,
        rituals: Optional[Mapping[str, Iterable[Mapping[str, Any]]]] = None,
        escalations: Optional[Mapping[str, Iterable[Mapping[str, Any]]]] = None,
        status_overrides: Optional[Mapping[str, str]] = None,
        membership_overrides: Optional[Mapping[str, int]] = None,
        llm_configs: Optional[Sequence[LLMConfig]] = None,
        theme: Optional[str] = None,
        context: Optional[Mapping[str, Any]] = None,
    ) -> GroupKeeperSyncResult:
        """Synchronise the state of community groups and capture guidance."""

        timestamp = (as_of or datetime.now(timezone.utc)).astimezone(timezone.utc)

        group_map: Dict[str, CommunityGroup] = {}
        for group in (*self._groups, *(groups or [])):
            group_map[group.name] = group
        if not group_map:
            raise ValueError("At least one community group must be provided for synchronisation")

        ritual_map: Dict[str, list[Mapping[str, Any]]] = {
            name: [dict(entry) for entry in entries]
            for name, entries in self._rituals.items()
        }
        for name, entries in (rituals or {}).items():
            key = str(name or "").strip()
            if not key:
                continue
            ritual_map.setdefault(key, []).extend(dict(entry or {}) for entry in entries or [])

        escalation_map: Dict[str, list[Mapping[str, Any]]] = {
            name: [dict(entry) for entry in entries]
            for name, entries in self._escalations.items()
        }
        for name, entries in (escalations or {}).items():
            key = str(name or "").strip()
            if not key:
                continue
            escalation_map.setdefault(key, []).extend(dict(entry or {}) for entry in entries or [])

        status_map: Dict[str, str] = {}
        for name, status in (status_overrides or {}).items():
            group_name = str(name or "").strip()
            status_value = str(status or "").strip()
            if group_name and status_value:
                status_map[group_name] = status_value

        membership_map: Dict[str, int] = {}
        for name, count in (membership_overrides or {}).items():
            group_name = str(name or "").strip()
            try:
                membership_value = int(count)
            except (TypeError, ValueError):
                continue
            if group_name:
                membership_map[group_name] = max(0, membership_value)

        groups_payload: list[MutableMapping[str, Any]] = []
        total_members = 0
        active_groups = 0
        for group in sorted(
            group_map.values(), key=lambda value: (-value.priority, value.name.lower())
        ):
            status = status_map.get(group.name, group.status)
            member_count = membership_map.get(group.name, group.member_count)
            payload: MutableMapping[str, Any] = {
                "name": group.name,
                "platform": group.platform,
                "owners": list(group.owners),
                "managers": list(group.managers),
                "purpose": group.purpose,
                "region": group.region,
                "status": status,
                "tags": list(group.tags),
                "channels": list(group.channels),
                "cadence": group.cadence,
                "member_count": member_count,
                "priority": group.priority,
                "metadata": dict(group.metadata),
            }
            groups_payload.append(payload)
            total_members += member_count
            if status.lower() in {"active", "launching"}:
                active_groups += 1

        rituals_payload: list[MutableMapping[str, Any]] = []
        for group_name, entries in ritual_map.items():
            for entry in entries:
                payload = dict(entry or {})
                payload.setdefault("group", group_name)
                rituals_payload.append(payload)

        escalations_payload: list[MutableMapping[str, Any]] = []
        for group_name, entries in escalation_map.items():
            for entry in entries:
                payload = dict(entry or {})
                payload.setdefault("group", group_name)
                escalations_payload.append(payload)

        metrics: Dict[str, Any] = {
            "total_groups": len(groups_payload),
            "active_groups": active_groups,
            "total_members": total_members,
        }

        prompt_lines = [
            "You are the Dynamic Capital community group keeper orchestrating community cohesion.",
            f"As of {timestamp.isoformat()} review the following groups:",
        ]
        if theme:
            prompt_lines.append(f"Theme: {theme}.")
        for payload in groups_payload:
            prompt_lines.append(
                f"- {payload['name']} ({payload['platform']}) — {payload['status']} with {payload['member_count']} members"
            )
        if rituals_payload:
            prompt_lines.append("Key rituals to reinforce:")
            for ritual in rituals_payload:
                name = ritual.get("name") or ritual.get("summary") or "Unnamed ritual"
                cadence = ritual.get("cadence") or ritual.get("schedule") or ""
                prompt_lines.append(
                    f"  * {ritual['group']}: {name}{' — ' + cadence if cadence else ''}"
                )
        if escalations_payload:
            prompt_lines.append("Open escalations:")
            for incident in escalations_payload:
                summary = incident.get("summary") or incident.get("issue") or "Follow-up"
                prompt_lines.append(f"  * {incident['group']}: {summary}")
        if context:
            prompt_lines.append(f"Additional context: {dict(context)}")

        prompt = "\n".join(prompt_lines)

        llm_runs: list[LLMRun] = []
        guidance_payloads: list[Mapping[str, Any]] = []
        for config in llm_configs or ():
            run = config.run(prompt)
            llm_runs.append(run)
            parsed = parse_json_response(run.response, fallback_key="insight")
            if parsed:
                guidance_payloads.append({"model": run.name, "payload": parsed})

        metadata: Dict[str, Any] = {"prompt": prompt}
        if context:
            metadata["context"] = dict(context)
        if guidance_payloads:
            metadata["llm_guidance"] = guidance_payloads

        return GroupKeeperSyncResult(
            timestamp=timestamp,
            theme=theme,
            groups=groups_payload,
            rituals=rituals_payload,
            escalations=escalations_payload,
            metrics=metrics,
            llm_runs=tuple(llm_runs),
            metadata=metadata,
        )

