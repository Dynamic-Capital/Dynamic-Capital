"""Broadcast channel keeper orchestration for Dynamic Capital."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Dict, Iterable, Mapping, MutableMapping, Optional, Sequence, Tuple

from .multi_llm import LLMConfig, LLMRun, parse_json_response

__all__ = [
    "BroadcastChannel",
    "ChannelKeeperSyncResult",
    "DynamicChannelKeeperAlgorithm",
]


def _normalise_tuple(values: Iterable[Any]) -> Tuple[str, ...]:
    """Return a tuple of unique, stripped string values preserving order."""

    seen: set[str] = set()
    items: list[str] = []
    for value in values or ():
        text = str(value).strip()
        if not text or text in seen:
            continue
        seen.add(text)
        items.append(text)
    return tuple(items)


@dataclass(slots=True, frozen=True)
class BroadcastChannel:
    """Represents a broadcast channel curated by the keeper."""

    name: str
    platform: str
    owner: str
    cadence: str = ""
    format: str = ""
    status: str = "live"
    audience_count: int = 0
    focus: str = ""
    managers: Tuple[str, ...] = ()
    distribution: Tuple[str, ...] = ()
    tags: Tuple[str, ...] = ()
    priority: int = 0
    metadata: Mapping[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        name = self.name.strip()
        platform = self.platform.strip()
        owner = self.owner.strip()
        if not name:
            raise ValueError("broadcast channel name is required")
        if not platform:
            raise ValueError("broadcast channel platform is required")
        if not owner:
            raise ValueError("broadcast channel owner is required")
        object.__setattr__(self, "name", name)
        object.__setattr__(self, "platform", platform)
        object.__setattr__(self, "owner", owner)
        object.__setattr__(self, "cadence", self.cadence.strip())
        object.__setattr__(self, "format", self.format.strip())
        object.__setattr__(self, "status", (self.status or "live").strip() or "live")
        object.__setattr__(self, "focus", self.focus.strip())
        object.__setattr__(self, "managers", _normalise_tuple(self.managers))
        object.__setattr__(self, "distribution", _normalise_tuple(self.distribution))
        object.__setattr__(self, "tags", _normalise_tuple(self.tags))
        object.__setattr__(self, "audience_count", max(0, int(self.audience_count)))
        object.__setattr__(self, "metadata", dict(self.metadata or {}))


@dataclass(slots=True)
class ChannelKeeperSyncResult:
    """Structured payload generated by :class:`DynamicChannelKeeperAlgorithm`."""

    timestamp: datetime
    theme: Optional[str]
    channels: Sequence[MutableMapping[str, Any]]
    campaigns: Sequence[MutableMapping[str, Any]]
    alerts: Sequence[MutableMapping[str, Any]]
    metrics: Mapping[str, Any]
    llm_runs: Tuple[LLMRun, ...] = ()
    metadata: Mapping[str, Any] = field(default_factory=dict)

    def summary(self) -> str:
        """Return a concise description of the synchronisation."""

        parts = [f"{len(self.channels)} channels"]
        if self.campaigns:
            parts.append(f"{len(self.campaigns)} campaigns")
        if self.alerts:
            parts.append(f"{len(self.alerts)} alerts")
        if self.theme:
            parts.append(f"theme '{self.theme}'")
        return ", ".join(parts)

    def to_dict(self) -> Dict[str, Any]:
        """Return a serialisable representation of the sync payload."""

        payload: Dict[str, Any] = {
            "timestamp": self.timestamp.isoformat(),
            "theme": self.theme,
            "channels": [dict(channel) for channel in self.channels],
            "campaigns": [dict(campaign) for campaign in self.campaigns],
            "alerts": [dict(alert) for alert in self.alerts],
            "metrics": dict(self.metrics),
            "summary": self.summary(),
        }
        if self.llm_runs:
            payload["llm_runs"] = [run.to_dict(include_prompt=False) for run in self.llm_runs]
        if self.metadata:
            payload["metadata"] = dict(self.metadata)
        return payload


class DynamicChannelKeeperAlgorithm:
    """Coordinates Dynamic Capital broadcast channels and campaigns."""

    def __init__(self) -> None:
        self._channels: list[BroadcastChannel] = []
        self._campaigns: Dict[str, list[Mapping[str, Any]]] = {}
        self._alerts: Dict[str, list[Mapping[str, Any]]] = {}

    def register_channel(self, channel: BroadcastChannel) -> None:
        """Register a persistent broadcast channel managed by the keeper."""

        self._channels.append(channel)

    def register_campaign(self, channel: str, campaign: Mapping[str, Any]) -> None:
        """Register an active or upcoming campaign for a channel."""

        name = channel.strip()
        if not name:
            raise ValueError("channel identifier is required for campaign registration")
        self._campaigns.setdefault(name, []).append(dict(campaign or {}))

    def register_alert(self, channel: str, alert: Mapping[str, Any]) -> None:
        """Register a delivery alert or incident for a channel."""

        name = channel.strip()
        if not name:
            raise ValueError("channel identifier is required for alert registration")
        self._alerts.setdefault(name, []).append(dict(alert or {}))

    def sync(
        self,
        *,
        as_of: Optional[datetime] = None,
        channels: Optional[Iterable[BroadcastChannel]] = None,
        campaigns: Optional[Mapping[str, Iterable[Mapping[str, Any]]]] = None,
        alerts: Optional[Mapping[str, Iterable[Mapping[str, Any]]]] = None,
        status_overrides: Optional[Mapping[str, str]] = None,
        audience_overrides: Optional[Mapping[str, int]] = None,
        llm_configs: Optional[Sequence[LLMConfig]] = None,
        theme: Optional[str] = None,
        context: Optional[Mapping[str, Any]] = None,
    ) -> ChannelKeeperSyncResult:
        """Synchronise broadcast channels and capture coordination guidance."""

        timestamp = (as_of or datetime.now(timezone.utc)).astimezone(timezone.utc)

        channel_map: Dict[str, BroadcastChannel] = {}
        for channel in (*self._channels, *(channels or [])):
            channel_map[channel.name] = channel
        if not channel_map:
            raise ValueError("At least one broadcast channel must be provided for synchronisation")

        campaign_map: Dict[str, list[Mapping[str, Any]]] = {
            name: [dict(entry) for entry in entries]
            for name, entries in self._campaigns.items()
        }
        for name, entries in (campaigns or {}).items():
            key = str(name or "").strip()
            if not key:
                continue
            campaign_map.setdefault(key, []).extend(dict(entry or {}) for entry in entries or [])

        alert_map: Dict[str, list[Mapping[str, Any]]] = {
            name: [dict(entry) for entry in entries]
            for name, entries in self._alerts.items()
        }
        for name, entries in (alerts or {}).items():
            key = str(name or "").strip()
            if not key:
                continue
            alert_map.setdefault(key, []).extend(dict(entry or {}) for entry in entries or [])

        status_map: Dict[str, str] = {}
        for name, status in (status_overrides or {}).items():
            channel_name = str(name or "").strip()
            status_value = str(status or "").strip()
            if channel_name and status_value:
                status_map[channel_name] = status_value

        audience_map: Dict[str, int] = {}
        for name, count in (audience_overrides or {}).items():
            channel_name = str(name or "").strip()
            try:
                audience_value = int(count)
            except (TypeError, ValueError):
                continue
            if channel_name:
                audience_map[channel_name] = max(0, audience_value)

        channels_payload: list[MutableMapping[str, Any]] = []
        total_audience = 0
        live_channels = 0
        for channel in sorted(
            channel_map.values(), key=lambda value: (-value.priority, value.name.lower())
        ):
            status = status_map.get(channel.name, channel.status)
            audience = audience_map.get(channel.name, channel.audience_count)
            payload: MutableMapping[str, Any] = {
                "name": channel.name,
                "platform": channel.platform,
                "owner": channel.owner,
                "managers": list(channel.managers),
                "cadence": channel.cadence,
                "format": channel.format,
                "status": status,
                "audience_count": audience,
                "focus": channel.focus,
                "distribution": list(channel.distribution),
                "tags": list(channel.tags),
                "priority": channel.priority,
                "metadata": dict(channel.metadata),
            }
            channels_payload.append(payload)
            total_audience += audience
            if status.lower() in {"live", "launching"}:
                live_channels += 1

        campaigns_payload: list[MutableMapping[str, Any]] = []
        for channel_name, entries in campaign_map.items():
            for entry in entries:
                payload = dict(entry or {})
                payload.setdefault("channel", channel_name)
                campaigns_payload.append(payload)

        alerts_payload: list[MutableMapping[str, Any]] = []
        for channel_name, entries in alert_map.items():
            for entry in entries:
                payload = dict(entry or {})
                payload.setdefault("channel", channel_name)
                alerts_payload.append(payload)

        metrics: Dict[str, Any] = {
            "total_channels": len(channels_payload),
            "live_channels": live_channels,
            "total_audience": total_audience,
        }

        prompt_lines = [
            "You are the Dynamic Capital broadcast channel keeper orchestrating distribution health.",
            f"As of {timestamp.isoformat()} review the channel portfolio:",
        ]
        if theme:
            prompt_lines.append(f"Theme: {theme}.")
        for payload in channels_payload:
            prompt_lines.append(
                f"- {payload['name']} ({payload['platform']}) — {payload['status']} reaching {payload['audience_count']} people"
            )
        if campaigns_payload:
            prompt_lines.append("Active campaigns:")
            for campaign in campaigns_payload:
                name = campaign.get("name") or campaign.get("summary") or "Unnamed campaign"
                window = campaign.get("window") or campaign.get("schedule") or ""
                prompt_lines.append(
                    f"  * {campaign['channel']}: {name}{' — ' + window if window else ''}"
                )
        if alerts_payload:
            prompt_lines.append("Delivery alerts:")
            for alert in alerts_payload:
                issue = alert.get("issue") or alert.get("summary") or "Alert"
                prompt_lines.append(f"  * {alert['channel']}: {issue}")
        if context:
            prompt_lines.append(f"Additional context: {dict(context)}")

        prompt = "\n".join(prompt_lines)

        llm_runs: list[LLMRun] = []
        guidance_payloads: list[Mapping[str, Any]] = []
        for config in llm_configs or ():
            run = config.run(prompt)
            llm_runs.append(run)
            parsed = parse_json_response(run.response, fallback_key="guidance")
            if parsed:
                guidance_payloads.append({"model": run.name, "payload": parsed})

        metadata: Dict[str, Any] = {"prompt": prompt}
        if context:
            metadata["context"] = dict(context)
        if guidance_payloads:
            metadata["llm_guidance"] = guidance_payloads

        return ChannelKeeperSyncResult(
            timestamp=timestamp,
            theme=theme,
            channels=channels_payload,
            campaigns=campaigns_payload,
            alerts=alerts_payload,
            metrics=metrics,
            llm_runs=tuple(llm_runs),
            metadata=metadata,
        )

