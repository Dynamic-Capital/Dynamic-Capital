"""Market intelligence workflow that ensembles Grok-1 with DeepSeek-V3."""

from __future__ import annotations

import json
import math
import textwrap
from dataclasses import dataclass, field
from typing import Any, Dict, Mapping, Optional, Sequence

from .grok_advisor import CompletionClient, GrokAdvisor
from .trade_logic import ActivePosition, MarketSnapshot


@dataclass(slots=True)
class MarketIntelligenceRequest:
    """Input payload for generating a market intelligence report."""

    snapshot: MarketSnapshot
    context: Dict[str, Any] = field(default_factory=dict)
    macro_events: Sequence[str] = field(default_factory=tuple)
    watchlist: Sequence[str] = field(default_factory=tuple)
    open_positions: Sequence[ActivePosition] = field(default_factory=tuple)
    analytics: Dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class MarketIntelligenceReport:
    """Structured output generated by :class:`MarketIntelligenceEngine`."""

    narrative: str
    opportunities: list[str]
    risks: list[str]
    recommended_actions: list[str]
    confidence: Optional[float]
    alerts: list[str]
    metadata: Dict[str, Any]
    raw_response: Optional[str]


@dataclass(slots=True)
class MarketIntelligenceEngine:
    """Coordinates Grok-1 insights with DeepSeek-V3 risk arbitration."""

    grok_client: CompletionClient
    deepseek_client: CompletionClient
    grok_temperature: float = 0.2
    grok_nucleus_p: float = 0.9
    grok_max_tokens: int = 384
    deepseek_temperature: float = 0.15
    deepseek_nucleus_p: float = 0.9
    deepseek_max_tokens: int = 384

    def generate_report(self, request: MarketIntelligenceRequest) -> MarketIntelligenceReport:
        """Return an aggregated intelligence brief for the supplied market state."""

        grok_prompt = self._build_grok_prompt(request)
        grok_response = self.grok_client.complete(
            grok_prompt,
            temperature=self.grok_temperature,
            max_tokens=self.grok_max_tokens,
            nucleus_p=self.grok_nucleus_p,
        )
        grok_payload = self._parse_payload(grok_response)

        deepseek_prompt = self._build_deepseek_prompt(request, grok_payload)
        deepseek_response = self.deepseek_client.complete(
            deepseek_prompt,
            temperature=self.deepseek_temperature,
            max_tokens=self.deepseek_max_tokens,
            nucleus_p=self.deepseek_nucleus_p,
        )
        deepseek_payload = self._parse_payload(deepseek_response)

        alerts = self._collect_strings(
            grok_payload.get("alerts"),
            deepseek_payload.get("alerts"),
        )

        opportunities = self._collect_strings(
            grok_payload.get("opportunities"),
            grok_payload.get("opportunity_summary"),
        )
        risks = self._collect_strings(
            grok_payload.get("risks"),
            deepseek_payload.get("risks"),
            deepseek_payload.get("risk_notes"),
        )
        actions = self._collect_strings(
            grok_payload.get("actions"),
            grok_payload.get("strategy_actions"),
            deepseek_payload.get("recommended_actions"),
        )

        narrative = self._resolve_narrative(grok_payload, deepseek_payload)
        confidence = self._resolve_confidence(grok_payload, deepseek_payload)

        metadata: Dict[str, Any] = {
            "grok": grok_payload,
            "deepseek": deepseek_payload,
        }

        raw_response = self._serialise_raw(
            {"model": "grok-1", "response": grok_response},
            {"model": "deepseek-v3", "response": deepseek_response},
        )

        return MarketIntelligenceReport(
            narrative=narrative,
            opportunities=opportunities,
            risks=risks,
            recommended_actions=actions,
            confidence=confidence,
            alerts=alerts,
            metadata=metadata,
            raw_response=raw_response,
        )

    def _build_grok_prompt(self, request: MarketIntelligenceRequest) -> str:
        snapshot_payload: Dict[str, Any] = {
            "symbol": request.snapshot.symbol,
            "timestamp": request.snapshot.timestamp.isoformat(),
            "close": request.snapshot.close,
            "rsi_fast": request.snapshot.rsi_fast,
            "adx_fast": request.snapshot.adx_fast,
            "rsi_slow": request.snapshot.rsi_slow,
            "adx_slow": request.snapshot.adx_slow,
            "pip_size": request.snapshot.pip_size,
            "pip_value": request.snapshot.pip_value,
            "seasonal_bias": request.snapshot.seasonal_bias,
            "seasonal_confidence": request.snapshot.seasonal_confidence,
        }
        if request.snapshot.correlation_scores:
            snapshot_payload["correlation_scores"] = request.snapshot.correlation_scores
        if request.snapshot.open is not None:
            snapshot_payload["open"] = request.snapshot.open
        if request.snapshot.high is not None:
            snapshot_payload["high"] = request.snapshot.high
        if request.snapshot.low is not None:
            snapshot_payload["low"] = request.snapshot.low

        positions_summary = [
            {
                "symbol": position.symbol,
                "direction": GrokAdvisor._direction(position.direction),
                "size": position.size,
                "entry_price": position.entry_price,
                "stop_loss": position.stop_loss,
                "take_profit": position.take_profit,
                "opened_at": position.opened_at.isoformat() if position.opened_at else None,
            }
            for position in request.open_positions
        ]

        payload = {
            "snapshot": snapshot_payload,
            "context": request.context,
            "macro_events": list(request.macro_events),
            "watchlist": list(request.watchlist),
            "open_positions": positions_summary,
            "analytics": request.analytics,
        }

        payload_json = json.dumps(payload, indent=2, default=str, sort_keys=True)

        return textwrap.dedent(
            f"""
            You are Grok-1 acting as the senior macro strategist for Dynamic Capital.
            Evaluate the market telemetry and think step-by-step about liquidity, momentum,
            and macro catalysts before responding. Return a single minified JSON object with:
              - "narrative": concise market story.
              - "opportunities": array of notable upside or relative value setups.
              - "risks": array of threats or cautionary dynamics.
              - "actions": array of recommended trading or hedging actions.
              - "confidence": optional number between 0 and 1 representing conviction.
              - "alerts": optional array of urgent callouts.
              - "data_signals": optional key metrics that influenced your reasoning.
            Do not include markdown or explanations outside the JSON payload.

            Market telemetry:
            {payload_json}
            """
        ).strip()

    def _build_deepseek_prompt(
        self,
        request: MarketIntelligenceRequest,
        grok_payload: Mapping[str, Any],
    ) -> str:
        snapshot_json = json.dumps(
            {
                "symbol": request.snapshot.symbol,
                "timestamp": request.snapshot.timestamp.isoformat(),
                "close": request.snapshot.close,
                "pip_size": request.snapshot.pip_size,
                "pip_value": request.snapshot.pip_value,
            },
            indent=2,
            default=str,
            sort_keys=True,
        )
        grok_json = json.dumps(grok_payload, indent=2, default=str, sort_keys=True)
        events_json = json.dumps(list(request.macro_events), indent=2, default=str)
        analytics_json = json.dumps(request.analytics, indent=2, default=str, sort_keys=True)

        return textwrap.dedent(
            f"""
            You are DeepSeek-V3 as Dynamic Capital's chief risk officer.
            Review the Grok-1 intelligence and audit it for blind spots. Work step-by-step
            through liquidity, regime stability, counterparty, and compliance risks before
            answering. Respond with a single minified JSON object containing:
              - "risk_score": optional value between 0 and 1 (higher means more risk).
              - "risks": optional array of identified risk narratives.
              - "alerts": optional array of immediate actions or warnings.
              - "recommended_actions": optional array of mitigations.
              - "confidence_modifier": optional multiplier for Grok confidence.
              - "adjusted_confidence": optional absolute confidence override.
              - "rationale": optional short explanation.
            Do not return any additional prose.

            Base snapshot:
            {snapshot_json}

            Grok-1 intelligence:
            {grok_json}

            Scheduled macro events:
            {events_json}

            Quantitative analytics:
            {analytics_json}
            """
        ).strip()

    @staticmethod
    def _parse_payload(response: str) -> Dict[str, Any]:
        parsed = GrokAdvisor._parse_response(response) or {}
        if not isinstance(parsed, dict):  # pragma: no cover - defensive fallback
            return {"response": response}
        return parsed

    @staticmethod
    def _collect_strings(*values: Any) -> list[str]:
        items: list[str] = []
        for value in values:
            if value is None:
                continue
            if isinstance(value, Sequence) and not isinstance(value, (str, bytes)):
                items.extend(str(item) for item in value)
            else:
                items.append(str(value))
        # Deduplicate while preserving order
        seen: set[str] = set()
        unique: list[str] = []
        for item in items:
            if item in seen:
                continue
            seen.add(item)
            unique.append(item)
        return unique

    @staticmethod
    def _resolve_narrative(
        grok_payload: Mapping[str, Any],
        deepseek_payload: Mapping[str, Any],
    ) -> str:
        for key in ("narrative", "summary", "market_view", "rationale"):
            value = grok_payload.get(key)
            if isinstance(value, str) and value.strip():
                return value.strip()
        value = deepseek_payload.get("rationale")
        if isinstance(value, str) and value.strip():
            return value.strip()
        return "No narrative supplied."

    @staticmethod
    def _resolve_confidence(
        grok_payload: Mapping[str, Any],
        deepseek_payload: Mapping[str, Any],
    ) -> Optional[float]:
        absolute = MarketIntelligenceEngine._extract_float(
            deepseek_payload,
            ("adjusted_confidence", "final_confidence"),
        )
        if absolute is not None:
            return MarketIntelligenceEngine._clamp(absolute)

        grok_confidence = MarketIntelligenceEngine._extract_float(
            grok_payload,
            ("confidence", "adjusted_confidence", "conviction"),
        )
        modifier = MarketIntelligenceEngine._extract_float(
            deepseek_payload,
            ("confidence_modifier", "confidence_scale", "multiplier"),
        )
        if grok_confidence is None and modifier is None:
            return None
        if grok_confidence is None:
            return MarketIntelligenceEngine._clamp(modifier)
        if modifier is None:
            return MarketIntelligenceEngine._clamp(grok_confidence)
        return MarketIntelligenceEngine._clamp(grok_confidence * modifier)

    @staticmethod
    def _extract_float(payload: Mapping[str, Any], keys: Sequence[str]) -> Optional[float]:
        for key in keys:
            value = payload.get(key)
            if value is None:
                continue
            try:
                number = float(value)
            except (TypeError, ValueError):
                continue
            if not math.isfinite(number):
                continue
            return number
        return None

    @staticmethod
    def _clamp(value: float) -> float:
        return max(0.0, min(1.0, value))

    @staticmethod
    def _serialise_raw(*entries: Mapping[str, Any]) -> Optional[str]:
        try:
            return json.dumps(list(entries))
        except (TypeError, ValueError):  # pragma: no cover - defensive fallback
            joined = []
            for entry in entries:
                joined.append(str(entry))
            return "\n".join(joined) if joined else None


__all__ = [
    "MarketIntelligenceEngine",
    "MarketIntelligenceReport",
    "MarketIntelligenceRequest",
]
