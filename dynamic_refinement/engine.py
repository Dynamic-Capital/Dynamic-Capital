"""Signal-driven refinement planning utilities.

The dynamic refinement engine ingests product or process steps and a
collection of feedback signals.  It produces ranked insights and a
lightweight action plan that focuses scarce capacity on the most
impactful refinements.  The module is intentionally small and
side-effect free so it can be embedded inside larger orchestration
systems without incurring heavy import cost.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Mapping, Sequence

__all__ = [
    "RefinementSignal",
    "RefinementStep",
    "RefinementInsight",
    "RefinementAction",
    "RefinementPlan",
    "DynamicRefinementEngine",
]


def _clamp(value: float, *, lower: float = 0.0, upper: float = 1.0) -> float:
    return max(lower, min(upper, value))


def _normalise_text(value: str) -> str:
    cleaned = value.strip()
    if not cleaned:
        raise ValueError("text value must not be empty")
    return cleaned


def _normalise_identifier(value: str) -> str:
    text = _normalise_text(value)
    return text


def _normalise_stage(value: str) -> str:
    text = _normalise_text(value).replace("-", "_").replace(" ", "_").lower()
    if not text:
        raise ValueError("stage must not be empty")
    return text


def _normalise_tags(tags: Sequence[str] | None) -> tuple[str, ...]:
    if not tags:
        return ()
    seen: set[str] = set()
    normalised: list[str] = []
    for tag in tags:
        cleaned = tag.strip().lower()
        if cleaned and cleaned not in seen:
            seen.add(cleaned)
            normalised.append(cleaned)
    return tuple(normalised)


_DEFAULT_STAGE_WEIGHTS: Mapping[str, float] = {
    "discovery": 0.95,
    "activation": 1.05,
    "validation": 1.0,
    "delivery": 1.08,
    "scaling": 1.12,
    "stabilisation": 1.02,
}


@dataclass(slots=True)
class RefinementSignal:
    """Observations or feedback that should inform prioritisation."""

    source: str
    theme: str
    intensity: float = 0.5
    alignment: float = 0.5
    urgency: float = 0.5
    target_stage: str | None = None
    target_tags: tuple[str, ...] = field(default_factory=tuple)
    notes: str | None = None
    weight: float = 1.0

    def __post_init__(self) -> None:
        self.source = _normalise_text(self.source)
        self.theme = _normalise_text(self.theme)
        self.intensity = _clamp(float(self.intensity))
        self.alignment = _clamp(float(self.alignment))
        self.urgency = _clamp(float(self.urgency))
        self.weight = max(float(self.weight), 0.0)
        if self.target_stage is not None:
            self.target_stage = _normalise_stage(self.target_stage)
        self.target_tags = _normalise_tags(self.target_tags)
        if self.notes is not None:
            self.notes = _normalise_text(self.notes)


@dataclass(slots=True)
class RefinementStep:
    """Work item or system lever that could benefit from refinement."""

    identifier: str
    summary: str
    stage: str = "discovery"
    impact: float = 0.5
    effort: float = 0.5
    risk: float = 0.4
    status: str = "pending"
    tags: tuple[str, ...] = field(default_factory=tuple)
    dependencies: tuple[str, ...] = field(default_factory=tuple)

    def __post_init__(self) -> None:
        self.identifier = _normalise_identifier(self.identifier)
        self.summary = _normalise_text(self.summary)
        self.stage = _normalise_stage(self.stage)
        self.impact = _clamp(float(self.impact))
        self.effort = _clamp(float(self.effort))
        self.risk = _clamp(float(self.risk))
        self.status = _normalise_text(self.status).lower()
        self.tags = _normalise_tags(self.tags)
        self.dependencies = tuple(_normalise_identifier(dep) for dep in self.dependencies)

    @property
    def effective_complexity(self) -> float:
        return _clamp(self.effort * 0.7 + self.risk * 0.3)


@dataclass(slots=True)
class RefinementInsight:
    """Ranked view of a single refinement step."""

    identifier: str
    summary: str
    stage: str
    priority: float
    confidence: float
    effort: float
    risk: float
    signals: tuple[str, ...]
    focus: str


@dataclass(slots=True)
class RefinementAction:
    """Concrete recommendation generated by the engine."""

    identifier: str
    stage: str
    action: str
    rationale: str
    confidence: float
    signals: tuple[str, ...]
    expected_outcome: str


@dataclass(slots=True)
class RefinementPlan:
    """Aggregated plan describing how to execute refinements."""

    focus_areas: tuple[str, ...]
    actions: tuple[RefinementAction, ...]
    deferred: tuple[str, ...]
    metrics: Mapping[str, float]
    narrative: str


@dataclass(slots=True)
class _ScoredStep:
    step: RefinementStep
    priority: float
    confidence: float
    signal_coverage: float
    matched_signals: tuple[RefinementSignal, ...]


class DynamicRefinementEngine:
    """Transform refinement signals into actionable plans."""

    def __init__(
        self,
        *,
        stage_weights: Mapping[str, float] | None = None,
        signal_bias: float = 0.6,
    ) -> None:
        weights = stage_weights or _DEFAULT_STAGE_WEIGHTS
        self._stage_weights = {
            _normalise_stage(stage): max(float(weight), 0.1)
            for stage, weight in weights.items()
        }
        self._signal_bias = _clamp(float(signal_bias), lower=0.0, upper=1.0)

    def rank(
        self,
        steps: Sequence[RefinementStep],
        signals: Sequence[RefinementSignal] | None = None,
    ) -> tuple[RefinementInsight, ...]:
        scored = self._score_steps(steps, signals or ())
        insights: list[RefinementInsight] = []
        for item in scored:
            focus = f"{item.step.stage} â€¢ {item.step.summary}"
            insight = RefinementInsight(
                identifier=item.step.identifier,
                summary=item.step.summary,
                stage=item.step.stage,
                priority=item.priority,
                confidence=item.confidence,
                effort=item.step.effort,
                risk=item.step.risk,
                signals=tuple(
                    f"{signal.source}: {signal.theme}" for signal in item.matched_signals
                ),
                focus=focus,
            )
            insights.append(insight)
        insights.sort(key=lambda insight: insight.priority, reverse=True)
        return tuple(insights)

    def refine(
        self,
        steps: Sequence[RefinementStep],
        signals: Sequence[RefinementSignal] | None = None,
        *,
        capacity: float = 1.0,
    ) -> RefinementPlan:
        scored = self._score_steps(steps, signals or ())
        scored.sort(key=lambda item: item.priority, reverse=True)

        remaining_capacity = max(float(capacity), 0.0)
        utilised_capacity = 0.0
        selected: list[_ScoredStep] = []
        deferred: list[str] = []

        for item in scored:
            required = item.step.effort
            if required <= remaining_capacity:
                selected.append(item)
                remaining_capacity -= required
                utilised_capacity += required
            else:
                deferred.append(item.step.identifier)

        actions: list[RefinementAction] = []
        focus_areas: list[str] = []
        total_priority = 0.0
        total_matched_signals = 0.0
        for item in selected:
            verb = "Accelerate" if item.priority >= 0.85 else "Advance"
            expected = self._build_expected_outcome(item.step)
            rationale = (
                "Priority {score:.2f} supported by {signals} signal(s) and "
                "confidence {confidence:.2f}."
            ).format(
                score=item.priority,
                signals=len(item.matched_signals),
                confidence=item.confidence,
            )
            action = RefinementAction(
                identifier=item.step.identifier,
                stage=item.step.stage,
                action=f"{verb} {item.step.summary}",
                rationale=rationale,
                confidence=item.confidence,
                signals=tuple(
                    f"{signal.source}: {signal.theme}" for signal in item.matched_signals
                ),
                expected_outcome=expected,
            )
            actions.append(action)
            focus_area = item.step.stage
            if focus_area not in focus_areas:
                focus_areas.append(focus_area)
            total_priority += item.priority
            total_matched_signals += len(item.matched_signals)

        metrics: dict[str, float] = {}
        if actions:
            metrics["utilised_capacity"] = round(utilised_capacity, 4)
            metrics["remaining_capacity"] = round(remaining_capacity, 4)
            metrics["average_priority"] = round(
                total_priority / len(actions),
                4,
            )
            if scored:
                metrics["signal_coverage"] = round(
                    total_matched_signals / max(len(signals or ()), 1),
                    4,
                )
        else:
            metrics["utilised_capacity"] = 0.0
            metrics["remaining_capacity"] = round(remaining_capacity, 4)
            metrics["average_priority"] = 0.0
            metrics["signal_coverage"] = 0.0

        narrative = self._build_narrative(actions, deferred, utilised_capacity, remaining_capacity)

        return RefinementPlan(
            focus_areas=tuple(focus_areas),
            actions=tuple(actions),
            deferred=tuple(deferred),
            metrics=metrics,
            narrative=narrative,
        )

    def _score_steps(
        self,
        steps: Sequence[RefinementStep],
        signals: Sequence[RefinementSignal],
    ) -> list[_ScoredStep]:
        scored: list[_ScoredStep] = []
        for step in steps:
            matched: list[RefinementSignal] = []
            adjustment = 0.0
            weighted_alignment = 0.0
            weight_total = 0.0
            stage_weight = self._stage_weights.get(step.stage, 1.0)
            base_priority = (
                0.5 * step.impact
                + 0.3 * (1.0 - step.effort)
                + 0.2 * (1.0 - step.risk)
            )
            for signal in signals:
                if not self._matches(step, signal):
                    continue
                influence = signal.weight * (
                    0.6 * signal.intensity + 0.4 * signal.urgency
                )
                if influence <= 0.0:
                    continue
                alignment_delta = signal.alignment - 0.5
                adjustment += influence * alignment_delta * self._signal_bias
                matched.append(signal)
                weighted_alignment += signal.alignment * influence
                weight_total += influence
            priority = _clamp(base_priority * stage_weight + adjustment)
            if weight_total:
                avg_alignment = weighted_alignment / weight_total
            else:
                avg_alignment = 0.5
            confidence = _clamp(
                0.3 * step.impact
                + 0.3 * (1.0 - step.risk)
                + 0.2 * (1.0 - step.effort)
                + 0.2 * avg_alignment
            )
            scored.append(
                _ScoredStep(
                    step=step,
                    priority=priority,
                    confidence=confidence,
                    signal_coverage=(weight_total if signals else 0.0),
                    matched_signals=tuple(matched),
                )
            )
        return scored

    def _matches(self, step: RefinementStep, signal: RefinementSignal) -> bool:
        if signal.target_stage and signal.target_stage != step.stage:
            return False
        if signal.target_tags:
            tag_overlap = set(signal.target_tags).intersection(step.tags)
            if not tag_overlap:
                return False
        return True

    def _build_expected_outcome(self, step: RefinementStep) -> str:
        if step.tags:
            lead_tag = step.tags[0]
            return f"Strengthen {lead_tag} indicators through measured iteration."
        return "Deliver measurable uplift across the primary KPI."

    def _build_narrative(
        self,
        actions: Sequence[RefinementAction],
        deferred: Sequence[str],
        utilised_capacity: float,
        remaining_capacity: float,
    ) -> str:
        if not actions:
            return "No refinement actions selected; expand capacity or gather richer signals."
        headline = actions[0]
        deferred_text = ", ".join(deferred) if deferred else "none"
        return (
            f"Lead with {headline.identifier} in {headline.stage} to deploy {utilised_capacity:.2f} "
            f"capacity. Remaining capacity {remaining_capacity:.2f}. Deferred: {deferred_text}."
        )
