"""Orchestration agent for the dynamic NFT engine."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Mapping, MutableMapping, Sequence

from dynamic_agents._insight import AgentInsight, utcnow
from dynamic.platform.token.nft import DynamicNFTMinter, MintedDynamicNFT

__all__ = ["NFTAgentInsight", "DynamicNFTAgent"]


@dataclass(slots=True)
class NFTAgentInsight:
    """Detailed payload generated by :class:`DynamicNFTAgent`."""

    raw: AgentInsight
    tokens: tuple[MintedDynamicNFT, ...]
    owner_distribution: Mapping[str, int]


class DynamicNFTAgent:
    """Coordinate :class:`dynamic.platform.token.nft.DynamicNFTMinter` operations."""

    domain = "Dynamic NFT Engine"

    def __init__(
        self,
        *,
        minter: DynamicNFTMinter | None = None,
        symbol: str = "DCT",
    ) -> None:
        self._minter = minter or DynamicNFTMinter(symbol)

    @property
    def minter(self) -> DynamicNFTMinter:
        """Expose the underlying minter for advanced workflows."""

        return self._minter

    # ------------------------------------------------------------------
    # lifecycle helpers

    def mint(
        self,
        owner: str,
        *,
        analysis: Mapping[str, object] | None = None,
        flow: Mapping[str, object] | None = None,
        pool: Mapping[str, object] | None = None,
        risk: Mapping[str, object] | None = None,
        tags: Sequence[str] | None = None,
        extra: Mapping[str, object] | None = None,
        timestamp: object | None = None,
    ) -> MintedDynamicNFT:
        """Mint a new NFT via the underlying engine."""

        return self._minter.mint(
            owner,
            analysis=analysis,
            flow=flow,
            pool=pool,
            risk=risk,
            tags=tags,
            extra=extra,
            timestamp=timestamp,
        )

    def refresh_metadata(
        self,
        token_id: int,
        *,
        analysis: Mapping[str, object] | None = None,
        flow: Mapping[str, object] | None = None,
        pool: Mapping[str, object] | None = None,
        risk: Mapping[str, object] | None = None,
        tags: Sequence[str] | None = None,
        extra: Mapping[str, object] | None = None,
        timestamp: object | None = None,
    ) -> MutableMapping[str, object]:
        """Refresh metadata for an existing NFT."""

        return self._minter.refresh_metadata(
            token_id,
            analysis=analysis,
            flow=flow,
            pool=pool,
            risk=risk,
            tags=tags,
            extra=extra,
            timestamp=timestamp,
        )

    def transfer(self, token_id: int, new_owner: str) -> MintedDynamicNFT:
        """Transfer ownership of an existing NFT."""

        return self._minter.transfer(token_id, new_owner)

    def get(self, token_id: int) -> MintedDynamicNFT:
        """Return a minted NFT by ``token_id``."""

        return self._minter.get(token_id)

    def all_tokens(self) -> tuple[MintedDynamicNFT, ...]:
        """Return all minted NFTs as an ordered tuple."""

        return tuple(self._minter.all_tokens())

    # ------------------------------------------------------------------
    # insight generation

    def generate_insight(self) -> AgentInsight:
        """Summarise the current NFT collection state."""

        tokens = self._minter.all_tokens()
        total_supply = len(tokens)
        unique_owners = len({token.owner for token in tokens}) if tokens else 0
        metrics = {
            "total_supply": total_supply,
            "unique_owners": unique_owners,
        }

        highlights: list[str] = []
        details: MutableMapping[str, object] = {}

        if tokens:
            latest = tokens[-1]
            metrics["latest_token_id"] = latest.token_id
            metrics["latest_owner_tokens"] = sum(
                1 for token in tokens if token.owner == latest.owner
            )
            highlights.append(
                f"Latest token #{latest.token_id} owned by {latest.owner}"
            )
            highlights.append(
                f"Collection spans {unique_owners} unique owners"
            )
        else:
            highlights.append("No dynamic NFTs minted yet")

        owner_distribution = self._build_owner_distribution(tokens)
        details["tokens"] = tuple(tokens)
        details["owner_distribution"] = owner_distribution

        return AgentInsight(
            domain=self.domain,
            generated_at=utcnow(),
            title=f"{self._minter.symbol} Dynamic NFT Overview",
            metrics=metrics,
            highlights=tuple(highlights),
            details=details,
        )

    def detailed_insight(self) -> NFTAgentInsight:
        """Return a richer insight bundle including collection details."""

        raw = self.generate_insight()
        tokens = raw.details.get("tokens") if raw.details else None
        if not isinstance(tokens, tuple):
            tokens = self.all_tokens()
        owner_distribution = (
            raw.details.get("owner_distribution") if raw.details else None
        )
        if not isinstance(owner_distribution, Mapping):
            owner_distribution = self._build_owner_distribution(tokens)
        return NFTAgentInsight(
            raw=raw,
            tokens=tuple(tokens),
            owner_distribution=dict(owner_distribution),
        )

    # ------------------------------------------------------------------
    # internal helpers

    def _build_owner_distribution(
        self, tokens: Iterable[MintedDynamicNFT]
    ) -> dict[str, int]:
        distribution: dict[str, int] = {}
        for token in tokens:
            distribution[token.owner] = distribution.get(token.owner, 0) + 1
        return distribution
