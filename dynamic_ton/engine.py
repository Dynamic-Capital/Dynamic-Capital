"""Operational planning tools for Dynamic Capital's TON deployments."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Mapping, MutableMapping, Sequence

__all__ = [
    "DynamicTonEngine",
    "TonAction",
    "TonExecutionPlan",
    "TonLiquidityPool",
    "TonNetworkTelemetry",
    "TonTreasuryPosture",
]


def _clamp(value: float, *, lower: float = 0.0, upper: float = 1.0) -> float:
    return max(lower, min(upper, value))


def _ensure_non_negative(value: float) -> float:
    return max(0.0, float(value))


def _normalise_text(value: str) -> str:
    if not isinstance(value, str):  # pragma: no cover - defensive guard
        raise TypeError("value must be a string")
    text = value.strip()
    if not text:
        raise ValueError("value must not be empty")
    return text


def _normalise_lower(value: str) -> str:
    return _normalise_text(value).lower()


def _normalise_upper(value: str) -> str:
    return _normalise_text(value).upper()


def _coerce_mapping(mapping: Mapping[str, object] | None) -> Mapping[str, object] | None:
    if mapping is None:
        return None
    if not isinstance(mapping, Mapping):  # pragma: no cover - defensive guard
        raise TypeError("metadata must be a mapping")
    return dict(mapping)


def _normalise_alerts(alerts: Sequence[str]) -> tuple[str, ...]:
    cleaned = []
    for alert in alerts:
        text = alert.strip()
        if text:
            cleaned.append(text)
    return tuple(cleaned)


_ALLOWED_PRIORITIES = {"low", "normal", "high"}


@dataclass(slots=True)
class TonLiquidityPool:
    """Represents live liquidity posture for a TON trading venue."""

    venue: str
    pair: str
    ton_depth: float
    quote_depth: float
    utilisation: float = 0.0

    def __post_init__(self) -> None:
        self.venue = _normalise_text(self.venue)
        self.pair = _normalise_upper(self.pair)
        self.ton_depth = _ensure_non_negative(self.ton_depth)
        self.quote_depth = _ensure_non_negative(self.quote_depth)
        self.utilisation = _clamp(float(self.utilisation))

    @property
    def depth_ratio(self) -> float:
        if self.quote_depth == 0:
            return 0.0
        return self.ton_depth / self.quote_depth


@dataclass(slots=True)
class TonNetworkTelemetry:
    """Describes ambient network conditions affecting TON execution."""

    ton_price_usd: float
    bridge_latency_ms: float
    settlement_backlog: int = 0
    ton_inflow_24h: float = 0.0
    ton_outflow_24h: float = 0.0

    def __post_init__(self) -> None:
        self.ton_price_usd = max(0.01, float(self.ton_price_usd))
        self.bridge_latency_ms = _ensure_non_negative(self.bridge_latency_ms)
        self.settlement_backlog = max(0, int(self.settlement_backlog))
        self.ton_inflow_24h = _ensure_non_negative(self.ton_inflow_24h)
        self.ton_outflow_24h = _ensure_non_negative(self.ton_outflow_24h)

    @property
    def net_flow(self) -> float:
        return self.ton_inflow_24h - self.ton_outflow_24h


@dataclass(slots=True)
class TonTreasuryPosture:
    """Treasury reserves and desired balance across TON exposures."""

    ton_reserve: float
    stable_reserve: float
    target_ton_ratio: float
    hedged_ratio: float = 0.0

    def __post_init__(self) -> None:
        self.ton_reserve = _ensure_non_negative(self.ton_reserve)
        self.stable_reserve = _ensure_non_negative(self.stable_reserve)
        self.target_ton_ratio = _clamp(float(self.target_ton_ratio))
        self.hedged_ratio = _clamp(float(self.hedged_ratio))

    @property
    def total_reserve(self) -> float:
        return self.ton_reserve + self.stable_reserve

    @property
    def current_ton_ratio(self) -> float:
        total = self.total_reserve
        if total == 0:
            return 0.0
        return self.ton_reserve / total


@dataclass(slots=True)
class TonAction:
    """Actionable step generated by the TON engine."""

    category: str
    description: str
    priority: str = "normal"
    metadata: Mapping[str, object] | None = None

    def __post_init__(self) -> None:
        self.category = _normalise_lower(self.category)
        self.description = _normalise_text(self.description)
        priority = _normalise_lower(self.priority)
        if priority not in _ALLOWED_PRIORITIES:
            raise ValueError(f"priority must be one of {_ALLOWED_PRIORITIES!r}")
        self.priority = priority
        self.metadata = _coerce_mapping(self.metadata)


@dataclass(slots=True)
class TonExecutionPlan:
    """Summary of recommended TON liquidity and treasury actions."""

    actions: tuple[TonAction, ...]
    alerts: tuple[str, ...] = field(default_factory=tuple)
    ton_allocation: Mapping[str, float] = field(default_factory=dict)
    expected_ton_ratio: float = 0.0
    commentary: str = ""

    def __post_init__(self) -> None:
        self.actions = tuple(self.actions)
        self.alerts = _normalise_alerts(self.alerts)
        allocation: MutableMapping[str, float] = {}
        for key, value in dict(self.ton_allocation).items():
            amount = _ensure_non_negative(value)
            if amount:
                allocation[_normalise_lower(key)] = amount
        self.ton_allocation = dict(allocation)
        self.expected_ton_ratio = _clamp(float(self.expected_ton_ratio))
        self.commentary = self.commentary.strip()

    @property
    def has_high_priority_actions(self) -> bool:
        return any(action.priority == "high" for action in self.actions)


class DynamicTonEngine:
    """Generate operational plans for TON liquidity and treasury management."""

    def __init__(
        self,
        *,
        min_total_depth_ton: float = 750_000.0,
        max_bridge_latency_ms: float = 900.0,
        utilisation_ceiling: float = 0.72,
        ratio_tolerance: float = 0.05,
    ) -> None:
        if min_total_depth_ton <= 0:
            raise ValueError("min_total_depth_ton must be positive")
        if max_bridge_latency_ms <= 0:
            raise ValueError("max_bridge_latency_ms must be positive")
        if not (0 < utilisation_ceiling <= 1):
            raise ValueError("utilisation_ceiling must be between 0 and 1")
        if not (0 <= ratio_tolerance < 1):
            raise ValueError("ratio_tolerance must be between 0 and 1")
        self._min_total_depth_ton = float(min_total_depth_ton)
        self._max_bridge_latency_ms = float(max_bridge_latency_ms)
        self._utilisation_ceiling = float(utilisation_ceiling)
        self._ratio_tolerance = float(ratio_tolerance)

    def build_plan(
        self,
        *,
        liquidity: Sequence[TonLiquidityPool],
        telemetry: TonNetworkTelemetry,
        treasury: TonTreasuryPosture,
    ) -> TonExecutionPlan:
        pools = tuple(liquidity)
        actions: list[TonAction] = []
        alerts: list[str] = []
        ton_allocation: dict[str, float] = {}

        total_depth = sum(pool.ton_depth for pool in pools)
        if total_depth < self._min_total_depth_ton:
            deficit = self._min_total_depth_ton - total_depth
            actions.append(
                TonAction(
                    category="liquidity",
                    description=(
                        f"Seed {deficit:,.0f} TON across pools to restore depth above "
                        f"{self._min_total_depth_ton:,.0f}."
                    ),
                    priority="high" if deficit > self._min_total_depth_ton * 0.2 else "normal",
                    metadata={"tonRequired": round(deficit, 2)},
                )
            )
            ton_allocation["liquidity"] = ton_allocation.get("liquidity", 0.0) + deficit

        for pool in pools:
            if pool.utilisation > self._utilisation_ceiling:
                actions.append(
                    TonAction(
                        category="liquidity",
                        description=(
                            f"Deploy liquidity relief on {pool.venue} {pool.pair} (utilisation "
                            f"{pool.utilisation:.0%})."
                        ),
                        priority="high",
                        metadata={
                            "venue": pool.venue,
                            "pair": pool.pair,
                            "utilisation": round(pool.utilisation, 4),
                        },
                    )
                )

        total_reserve = treasury.total_reserve
        expected_ratio = treasury.current_ton_ratio
        if total_reserve > 0:
            desired_ton = total_reserve * treasury.target_ton_ratio
            gap = desired_ton - treasury.ton_reserve
            tolerance_amount = total_reserve * self._ratio_tolerance
            if abs(gap) > tolerance_amount:
                if gap > 0:
                    actions.append(
                        TonAction(
                            category="treasury",
                            description=(
                                "Accumulate additional TON to close the reserve gap and reach the "
                                f"{treasury.target_ton_ratio:.0%} target ratio."
                            ),
                            priority="normal",
                            metadata={"tonShortfall": round(gap, 2)},
                        )
                    )
                    ton_allocation["accumulate_ton"] = ton_allocation.get("accumulate_ton", 0.0) + gap
                else:
                    adjustment = abs(gap)
                    actions.append(
                        TonAction(
                            category="treasury",
                            description=(
                                "Rotate TON back into stables to respect the treasury exposure "
                                f"target of {treasury.target_ton_ratio:.0%}."
                            ),
                            priority="normal",
                            metadata={"tonToRelease": round(adjustment, 2)},
                        )
                    )
                    ton_allocation["rebalance_to_stables"] = (
                        ton_allocation.get("rebalance_to_stables", 0.0) + adjustment
                    )
                expected_ratio = treasury.target_ton_ratio

        if telemetry.bridge_latency_ms > self._max_bridge_latency_ms:
            alerts.append(
                "Bridge latency exceeding threshold; queue settlements via alternative rails."
            )
            actions.append(
                TonAction(
                    category="infrastructure",
                    description="Escalate TON bridge latency incident with providers.",
                    priority="high",
                    metadata={
                        "latencyMs": round(telemetry.bridge_latency_ms, 2),
                        "thresholdMs": round(self._max_bridge_latency_ms, 2),
                    },
                )
            )

        if telemetry.settlement_backlog > 0:
            alerts.append(
                f"{telemetry.settlement_backlog} TON settlements pending; prioritise clearing."
            )

        if telemetry.net_flow < 0:
            deficit = abs(telemetry.net_flow)
            actions.append(
                TonAction(
                    category="treasury",
                    description=(
                        "Net TON outflows detected over the last 24h; top up buffers to prevent "
                        "liquidity stress."
                    ),
                    priority="high" if deficit > total_reserve * 0.1 else "normal",
                    metadata={"netOutflow": round(deficit, 2)},
                )
            )
            ton_allocation["buffer_top_up"] = ton_allocation.get("buffer_top_up", 0.0) + deficit

        commentary = (
            "Plan emphasises maintaining resilient TON liquidity, addressing treasury "
            "balance targets, and mitigating infrastructure friction."
        )

        return TonExecutionPlan(
            actions=tuple(actions),
            alerts=tuple(alerts),
            ton_allocation=ton_allocation,
            expected_ton_ratio=expected_ratio,
            commentary=commentary,
        )
