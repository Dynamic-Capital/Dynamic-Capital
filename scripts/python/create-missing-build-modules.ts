import { mkdir, readFile, writeFile } from "node:fs/promises";
import { dirname, join, relative, resolve } from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

import {
  DEFAULT_PREFIX,
  findMissingBuildModules,
  listCandidatePackages,
  type PackageInfo,
  type PackageReport,
  pathExists,
} from "./build-module-utils.ts";

interface CliOptions {
  root: string;
  prefix: string;
  force: boolean;
  dryRun: boolean;
  packages: string[];
}

type FileStatus = "created" | "updated" | "skipped";

interface FileMutation {
  filePath: string;
  status: FileStatus;
}

interface CreationResult {
  package: PackageInfo;
  files: FileMutation[];
}

function parseArgs(argv: string[]): CliOptions {
  const options: CliOptions = {
    root: resolve(dirname(fileURLToPath(import.meta.url)), "..", ".."),
    prefix: DEFAULT_PREFIX,
    force: false,
    dryRun: false,
    packages: [],
  };

  for (let index = 0; index < argv.length; index += 1) {
    const value = argv[index];

    if (value === "--root" || value === "-r") {
      const next = argv[index + 1];
      if (!next) {
        throw new Error("--root flag requires a path argument");
      }
      options.root = resolve(next);
      index += 1;
      continue;
    }

    if (value === "--prefix") {
      const next = argv[index + 1];
      if (!next) {
        throw new Error("--prefix flag requires a value");
      }
      options.prefix = next;
      index += 1;
      continue;
    }

    if (value === "--force") {
      options.force = true;
      continue;
    }

    if (value === "--dry-run") {
      options.dryRun = true;
      continue;
    }

    if (value === "--package" || value === "-p") {
      const next = argv[index + 1];
      if (!next) {
        throw new Error("--package flag requires a package name");
      }
      options.packages.push(next);
      index += 1;
      continue;
    }

    if (value.startsWith("-")) {
      throw new Error(`Unknown flag: ${value}`);
    }
  }

  return options;
}

function createModuleSource(packageName: string): string {
  const modulePath = `${packageName}.build`;
  return `"""Autogenerated placeholder build module for ${packageName}."""

from __future__ import annotations

from typing import Any, Mapping

from dynamic_build_stub import build_placeholder, main_placeholder

__all__ = ("build", "main")


def build(*args: Any, **kwargs: Any) -> Mapping[str, Any]:
    """Proxy to the shared build placeholder for ${packageName}."""
    return build_placeholder("${packageName}", *args, **kwargs)


def main() -> int:
    """Entry point for "python -m ${modulePath}"."""
    return main_placeholder("${packageName}")


if __name__ == "__main__":  # pragma: no cover - CLI shim
    raise SystemExit(main())

`;
}

async function ensureDirectory(
  directoryPath: string,
  options: CliOptions,
): Promise<void> {
  if (await pathExists(directoryPath)) {
    return;
  }

  if (options.dryRun) {
    return;
  }

  await mkdir(directoryPath, { recursive: true });
}

async function writeFileIfNeeded(
  filePath: string,
  contents: string,
  options: CliOptions,
): Promise<FileStatus> {
  const exists = await pathExists(filePath);

  if (exists && !options.force) {
    return "skipped";
  }

  if (exists) {
    try {
      const current = await readFile(filePath, { encoding: "utf-8" });
      if (current === contents) {
        return "skipped";
      }
    } catch {
      // Unable to read the existing file; fall through to rewrite it.
    }
  }

  if (!options.dryRun) {
    await ensureDirectory(dirname(filePath), options);
    await writeFile(filePath, contents, { encoding: "utf-8" });
  }

  return exists ? "updated" : "created";
}

async function writeBuildModule(
  pkg: PackageInfo,
  options: CliOptions,
): Promise<CreationResult> {
  const filePath = join(pkg.path, "build.py");
  const source = createModuleSource(pkg.name);
  const status = await writeFileIfNeeded(filePath, source, options);

  return {
    package: pkg,
    files: [{ filePath, status }],
  };
}

function printReport(
  root: string,
  reports: PackageReport[],
  creations: CreationResult[],
  dryRun: boolean,
): void {
  const changed = creations.filter((item) =>
    item.files.some((file) => file.status !== "skipped")
  );
  const skipped = creations.filter((item) =>
    item.files.every((file) => file.status === "skipped")
  );

  if (reports.length === 0) {
    console.log("No missing build modules detected.");
    return;
  }

  console.log(`Root scanned: ${root}`);
  console.log(`Packages analysed: ${reports.length}`);
  console.log(
    `Modules ${
      dryRun ? "to be created or updated" : "created or updated"
    }: ${changed.length}`,
  );
  console.log(`Skipped (existing): ${skipped.length}`);

  if (changed.length > 0) {
    console.log("");
    console.log(dryRun ? "Pending updates:" : "Updated modules:");
    for (const item of changed) {
      for (const file of item.files) {
        if (file.status === "skipped") {
          continue;
        }
        console.log(
          `- ${item.package.name}: ${file.filePath} (${file.status})`,
        );
      }
    }
  }

  if (skipped.length > 0) {
    console.log("");
    console.log("Skipped packages (existing module detected):");
    for (const item of skipped) {
      for (const file of item.files) {
        console.log(`- ${item.package.name}: ${file.filePath}`);
      }
    }
  }
}

async function main(): Promise<void> {
  try {
    const options = parseArgs(process.argv.slice(2));
    const candidates = await listCandidatePackages(
      options.root,
      options.prefix,
    );

    const filteredCandidates = options.packages.length === 0
      ? candidates
      : candidates.filter((pkg) => options.packages.includes(pkg.name));

    const missingSelections = options.packages.filter((name) =>
      !candidates.some((pkg) => pkg.name === name)
    );

    if (missingSelections.length > 0) {
      console.warn(
        `Requested packages not found: ${missingSelections.join(", ")}`,
      );
    }

    const missing = await findMissingBuildModules(
      filteredCandidates,
      options.root,
    );

    if (missing.length === 0 && !options.force) {
      console.log("All packages already expose build modules.");
      return;
    }

    const candidatesToUse = filteredCandidates;

    const targets = options.force ? candidatesToUse : missing.map((report) => ({
      name: report.name,
      path: join(options.root, report.path),
    }));

    if (targets.length === 0) {
      console.log("No matching packages found to process.");
      return;
    }

    const creations: CreationResult[] = [];

    for (const pkg of targets) {
      creations.push(await writeBuildModule(pkg, options));
    }

    const reportsForLogging: PackageReport[] = options.force
      ? targets.map((pkg) => ({
        name: pkg.name,
        path: relative(options.root, pkg.path),
        expected: [join(relative(options.root, pkg.path), "build.py")],
      }))
      : missing;

    printReport(options.root, reportsForLogging, creations, options.dryRun);
  } catch (error) {
    console.error("Failed to create build modules:");
    if (error instanceof Error) {
      console.error(error.message);
      if (error.stack) {
        console.error(error.stack);
      }
    } else {
      console.error(error);
    }
    process.exitCode = 1;
  }
}

await main();
