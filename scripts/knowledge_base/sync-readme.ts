import { readFile, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

type DropFile = {
  path: string;
  purpose: string;
};

type Drop = {
  id: string;
  title: string;
  manifest: string;
  supabase_mirror: string;
  description: string;
  files: DropFile[];
};

type Share = {
  id: string;
  title: string;
  share_link: string;
  graph_helper: string;
  status: string;
  actions?: string[];
};

type Staging = {
  title: string;
  source_location: string;
  supabase_mirror: string;
  description: string;
  files: DropFile[];
};

type KnowledgeBaseIndex = {
  intro: string;
  drops: Drop[];
  shares: Share[];
  staging: Staging;
  maintenance?: string[];
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const repoRoot = resolve(__dirname, "..", "..");
const indexPath = resolve(repoRoot, "data", "knowledge_base", "index.json");
const readmePath = resolve(repoRoot, "data", "knowledge_base", "README.md");

function toMarkdownTable(headers: string[], rows: string[][]): string {
  const headerRow = `| ${headers.join(" | ")} |`;
  const divider = `| ${headers.map(() => "---").join(" | ")} |`;
  const body = rows.map((row) => `| ${row.join(" | ")} |`).join("\n");
  return [headerRow, divider, body].filter(Boolean).join("\n");
}

function formatLink(label: string, target: string): string {
  return target ? `[${label}](${target})` : label;
}

function renderDrops(drops: Drop[]): string {
  if (!drops.length) {
    return "No knowledge base drops have been recorded yet.";
  }

  const summaryTable = toMarkdownTable(
    ["Date", "Title", "Manifest", "Supabase mirror"],
    drops.map((drop) => [
      drop.id,
      drop.title,
      formatLink(drop.manifest, `../${drop.manifest}`),
      `\`${drop.supabase_mirror}\``,
    ]),
  );

  const detailSections = drops.map((drop) => {
    const bullets = [
      `- **Source manifest:** ${
        formatLink(drop.manifest, `../${drop.manifest}`)
      }`,
      `- **Supabase mirror:** \`${drop.supabase_mirror}\``,
      `- **Description:** ${drop.description}`,
    ];

    const filesTable = drop.files.length
      ? toMarkdownTable(
        ["Relative path", "Purpose"],
        drop.files.map((file) => [`\`${file.path}\``, file.purpose]),
      )
      : "(No files recorded yet.)";

    return [
      `### ${drop.id} â€” ${drop.title}`,
      "",
      bullets.join("\n"),
      "",
      "#### Files",
      "",
      filesTable,
    ].join("\n");
  });

  return [
    "### Drops",
    "",
    summaryTable,
    "",
    ...detailSections,
  ].join("\n");
}

function renderShares(shares: Share[]): string {
  if (!shares.length) {
    return "No active OneDrive shares are being monitored.";
  }

  const summaryTable = toMarkdownTable(
    ["Share", "Helper", "Status"],
    shares.map((share) => [
      formatLink(share.title, share.share_link),
      formatLink(share.graph_helper, `../${share.graph_helper}`),
      share.status,
    ]),
  );

  const detailSections = shares.map((share) => {
    const bullets = [
      `- **Share link:** ${share.share_link}`,
      `- **Graph helper:** ${
        formatLink(share.graph_helper, `../${share.graph_helper}`)
      }`,
      `- **Status:** ${share.status}`,
    ];

    const actions = share.actions?.length
      ? [
        "",
        "#### Next actions",
        "",
        ...share.actions.map((action) => `- ${action}`),
      ]
      : [];

    return [
      `### ${share.title}`,
      "",
      bullets.join("\n"),
      ...actions,
    ].join("\n");
  });

  return [
    "### Active OneDrive shares",
    "",
    summaryTable,
    "",
    ...detailSections,
  ].join("\n");
}

function renderStaging(staging: Staging): string {
  const bullets = [
    `- **Source location:** \`${staging.source_location}\``,
    `- **Supabase mirror:** \`${staging.supabase_mirror}\``,
    `- **Description:** ${staging.description}`,
  ];

  const filesTable = staging.files.length
    ? toMarkdownTable(
      ["Relative path", "Purpose"],
      staging.files.map((file) => [`\`${file.path}\``, file.purpose]),
    )
    : "(No staging artefacts recorded yet.)";

  return [
    "### Research staging",
    "",
    bullets.join("\n"),
    "",
    "#### Files",
    "",
    filesTable,
  ].join("\n");
}

async function main() {
  const raw = await readFile(indexPath, "utf8");
  const index = JSON.parse(raw) as KnowledgeBaseIndex;

  const header = [
    "# Knowledge Base Drops",
    "<!-- DO NOT EDIT: generated by scripts/knowledge_base/sync-readme.ts -->",
    "",
    index.intro,
    "",
    "Run `npx tsx scripts/knowledge_base/sync-readme.ts` after updating `index.json` to refresh this overview.",
    "",
  ].join("\n");

  const sectionParts = [""];

  if (index.maintenance?.length) {
    sectionParts.push(
      "### Maintenance notes",
      "",
      ...index.maintenance.map((item) => `- ${item}`),
      "",
    );
  }

  sectionParts.push(
    renderDrops(index.drops),
    "",
    renderShares(index.shares),
    "",
    renderStaging(index.staging),
  );

  const sections = sectionParts.join("\n");

  const content = `${header}${sections}\n`;
  await writeFile(readmePath, content, "utf8");
}

await main();
