/* esm.sh - @tonconnect/sdk@2.2.0 */
import{CONNECT_EVENT_ERROR_CODES as w,SEND_TRANSACTION_ERROR_CODES as C,Base64 as F,SessionCrypto as Z,hexToByteArray as Q}from"/@tonconnect/protocol@^2.2.5?target=denonext";import{CHAIN as _e,CONNECT_ITEM_ERROR_CODES as Te}from"/@tonconnect/protocol@^2.2.5?target=denonext";import"/@tonconnect/isomorphic-eventsource@^0.0.1?target=denonext";import"/@tonconnect/isomorphic-fetch@^0.0.2?target=denonext";function ne(s,e){var t={};for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&e.indexOf(n)<0&&(t[n]=s[n]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,n=Object.getOwnPropertySymbols(s);i<n.length;i++)e.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(s,n[i])&&(t[n[i]]=s[n[i]]);return t}function r(s,e,t,n){function i(o){return o instanceof t?o:new t(function(a){a(o)})}return new(t||(t=Promise))(function(o,a){function d(l){try{g(n.next(l))}catch(x){a(x)}}function y(l){try{g(n.throw(l))}catch(x){a(x)}}function g(l){l.done?o(l.value):i(l.value).then(d,y)}g((n=n.apply(s,e||[])).next())})}var c=class s extends Error{constructor(e,t){super(e,t),this.message=`${s.prefix} ${this.constructor.name}${this.info?": "+this.info:""}${e?`
`+e:""}`,Object.setPrototypeOf(this,s.prototype)}get info(){return""}};c.prefix="[TON_CONNECT_SDK_ERROR]";var k=class s extends c{get info(){return"Passed DappMetadata is in incorrect format."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},I=class s extends c{get info(){return"Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},j=class s extends c{get info(){return"Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},U=class s extends c{get info(){return"Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},E=class s extends c{get info(){return"Send transaction or other protocol methods called while wallet is not connected."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}};function se(s){return"jsBridgeKey"in s}var L=class s extends c{get info(){return"User rejects the action in the wallet."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},_=class s extends c{get info(){return"Request to the wallet contains errors."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},T=class s extends c{get info(){return"App tries to send rpc request to the injected wallet while not connected."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},A=class s extends c{get info(){return"There is an attempt to connect to the injected wallet while it is not exists in the webpage."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},q=class s extends c{get info(){return"Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},K=class s extends c{get info(){return"An error occurred while fetching the wallets list."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},m=class s extends c{get info(){return"Passed address is in incorrect format."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},W=class s extends c{get info(){return"Passed hex is in incorrect format."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},p=class s extends c{constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}},V={[w.UNKNOWN_ERROR]:p,[w.USER_REJECTS_ERROR]:L,[w.BAD_REQUEST_ERROR]:_,[w.UNKNOWN_APP_ERROR]:T,[w.MANIFEST_NOT_FOUND_ERROR]:j,[w.MANIFEST_CONTENT_ERROR]:I},B=class{parseError(e){let t=p;return e.code in V&&(t=V[e.code]||p),new t(e.message)}},ie=new B,M=class{isError(e){return"error"in e}},X={[C.UNKNOWN_ERROR]:p,[C.USER_REJECTS_ERROR]:L,[C.BAD_REQUEST_ERROR]:_,[C.UNKNOWN_APP_ERROR]:T},D=class extends M{convertToRpcRequest(e){return{method:"sendTransaction",params:[JSON.stringify(e)]}}parseAndThrowError(e){let t=p;throw e.error.code in X&&(t=X[e.error.code]||p),new t(e.error.message)}convertFromRpcResponse(e){return{boc:e.result}}},O=new D,G=class{constructor(e,t){this.storage=e,this.storeKey="ton-connect-storage_http-bridge-gateway::"+t}storeLastEventId(e){return r(this,void 0,void 0,function*(){return this.storage.setItem(this.storeKey,e)})}removeLastEventId(){return r(this,void 0,void 0,function*(){return this.storage.removeItem(this.storeKey)})}getLastEventId(){return r(this,void 0,void 0,function*(){let e=yield this.storage.getItem(this.storeKey);return e||null})}};function oe(s){return s.slice(-1)==="/"?s.slice(0,-1):s}function z(s,e){return oe(s)+"/"+e}function re(s){let e=new URL(s);return e.protocol==="tg:"||e.hostname==="t.me"}var v=class{constructor(e,t,n,i,o){this.bridgeUrl=t,this.sessionId=n,this.listener=i,this.errorsListener=o,this.ssePath="events",this.postPath="message",this.heartbeatMessage="heartbeat",this.defaultTtl=300,this.isClosed=!1,this.bridgeGatewayStorage=new G(e,t)}registerSession(){return r(this,void 0,void 0,function*(){let e=new URL(z(this.bridgeUrl,this.ssePath));e.searchParams.append("client_id",this.sessionId);let t=yield this.bridgeGatewayStorage.getLastEventId();if(!this.isClosed)return t&&e.searchParams.append("last_event_id",t),this.eventSource=new EventSource(e.toString()),new Promise((n,i)=>{this.eventSource.onerror=i,this.eventSource.onopen=()=>{this.eventSource.onerror=this.errorsHandler.bind(this),this.eventSource.onmessage=this.messagesHandler.bind(this),n()}})})}send(e,t,n,i){return r(this,void 0,void 0,function*(){let o=new URL(z(this.bridgeUrl,this.postPath));o.searchParams.append("client_id",this.sessionId),o.searchParams.append("to",t),o.searchParams.append("ttl",(i||this.defaultTtl).toString()),o.searchParams.append("topic",n),yield fetch(o,{method:"post",body:F.encode(e)})})}pause(){var e;(e=this.eventSource)===null||e===void 0||e.close()}unPause(){return this.registerSession()}close(){var e;this.isClosed=!0,(e=this.eventSource)===null||e===void 0||e.close()}setListener(e){this.listener=e}setErrorsListener(e){this.errorsListener=e}errorsHandler(e){var t,n;if(!this.isClosed){if(((t=this.eventSource)===null||t===void 0?void 0:t.readyState)===EventSource.CLOSED){this.eventSource.close(),this.registerSession();return}if(((n=this.eventSource)===null||n===void 0?void 0:n.readyState)===EventSource.CONNECTING){console.debug("[TON_CONNET_SDK_ERROR]: Bridge error",JSON.stringify(e));return}this.errorsListener(e)}}messagesHandler(e){return r(this,void 0,void 0,function*(){if(e.data!==this.heartbeatMessage&&(yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId),!this.isClosed)){let t;try{t=JSON.parse(e.data)}catch(n){throw new c(`Bridge message parse failed, message ${n.data}`)}this.listener(t)}})}},f=class{constructor(e){this.storage=e,this.storeKey="ton-connect-storage_bridge-connection"}storeConnection(e){return r(this,void 0,void 0,function*(){if(e.type==="injected")return this.storage.setItem(this.storeKey,JSON.stringify(e));let t={sessionKeyPair:e.session.sessionCrypto.stringifyKeypair(),walletPublicKey:e.session.walletPublicKey,bridgeUrl:e.session.bridgeUrl},n={type:"http",connectEvent:e.connectEvent,session:t,lastWalletEventId:e.lastWalletEventId,nextRpcRequestId:e.nextRpcRequestId};return this.storage.setItem(this.storeKey,JSON.stringify(n))})}removeConnection(){return r(this,void 0,void 0,function*(){return this.storage.removeItem(this.storeKey)})}getConnection(){return r(this,void 0,void 0,function*(){let e=yield this.storage.getItem(this.storeKey);if(!e)return null;let t=JSON.parse(e);if(t.type==="injected")return t;let n=new Z(t.session.sessionKeyPair);return{type:"http",connectEvent:t.connectEvent,lastWalletEventId:t.lastWalletEventId,nextRpcRequestId:t.nextRpcRequestId,session:{sessionCrypto:n,bridgeUrl:t.session.bridgeUrl,walletPublicKey:t.session.walletPublicKey}}})}getHttpConnection(){return r(this,void 0,void 0,function*(){let e=yield this.getConnection();if(!e)throw new c("Trying to read HTTP connection source while nothing is stored");if(e.type==="injected")throw new c("Trying to read HTTP connection source while injected connection is stored");return e})}getInjectedConnection(){return r(this,void 0,void 0,function*(){let e=yield this.getConnection();if(!e)throw new c("Trying to read Injected bridge connection source while nothing is stored");if(e?.type==="http")throw new c("Trying to read Injected bridge connection source while HTTP connection is stored");return e})}storedConnectionType(){return r(this,void 0,void 0,function*(){let e=yield this.storage.getItem(this.storeKey);return e?JSON.parse(e).type:null})}storeLastWalletEventId(e){return r(this,void 0,void 0,function*(){let t=yield this.getConnection();if(t&&t.type==="http")return t.lastWalletEventId=e,this.storeConnection(t)})}getLastWalletEventId(){return r(this,void 0,void 0,function*(){let e=yield this.getConnection();if(e&&"lastWalletEventId"in e)return e.lastWalletEventId})}increaseNextRpcRequestId(){return r(this,void 0,void 0,function*(){let e=yield this.getConnection();if(e){let t=e.nextRpcRequestId||0;return e.nextRpcRequestId=t+1,this.storeConnection(e)}})}getNextRpcRequestId(){return r(this,void 0,void 0,function*(){let e=yield this.getConnection();return e&&e.nextRpcRequestId||0})}},ee=2;function h(...s){try{console.debug("[TON_CONNECT_SDK]",...s)}catch{}}function R(...s){try{console.error("[TON_CONNECT_SDK]",...s)}catch{}}function ae(...s){try{console.warn("[TON_CONNECT_SDK]",...s)}catch{}}var P=class s{constructor(e,t){this.storage=e,this.walletConnectionSource=t,this.type="http",this.standardUniversalLink="tc://",this.pendingRequests=new Map,this.session=null,this.gateway=null,this.pendingGateways=[],this.listeners=[],this.connectionStorage=new f(e)}static fromStorage(e){return r(this,void 0,void 0,function*(){let n=yield new f(e).getHttpConnection();return new s(e,{bridgeUrl:n.session.bridgeUrl})})}connect(e){this.closeGateways();let t=new Z,n="",i=this.standardUniversalLink;return Array.isArray(this.walletConnectionSource)?(this.pendingGateways=this.walletConnectionSource.map(o=>{let a=new v(this.storage,o.bridgeUrl,t.sessionId,()=>{},d=>{console.error(d)});return a.setListener(d=>this.pendingGatewaysListener(a,o.bridgeUrl,d)),a}),this.pendingGateways.forEach(o=>o.registerSession())):(n=this.walletConnectionSource.bridgeUrl,this.walletConnectionSource.universalLink&&(i=this.walletConnectionSource.universalLink),this.gateway=new v(this.storage,this.walletConnectionSource.bridgeUrl,t.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),this.gateway.registerSession()),this.session={sessionCrypto:t,bridgeUrl:n},this.generateUniversalLink(i,e)}restoreConnection(){return r(this,void 0,void 0,function*(){if(Array.isArray(this.walletConnectionSource))throw new c("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");this.closeGateways();let e=yield this.connectionStorage.getHttpConnection();e&&(this.session=e.session,this.gateway=new v(this.storage,this.walletConnectionSource.bridgeUrl,e.session.sessionCrypto.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),yield this.gateway.registerSession(),this.listeners.forEach(t=>t(e.connectEvent)))})}sendRequest(e,t){return new Promise((n,i)=>r(this,void 0,void 0,function*(){if(!this.gateway||!this.session||!("walletPublicKey"in this.session))throw new c("Trying to send bridge request without session");let o=(yield this.connectionStorage.getNextRpcRequestId()).toString();yield this.connectionStorage.increaseNextRpcRequestId(),h("Send http-bridge request:",Object.assign(Object.assign({},e),{id:o}));let a=this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({},e),{id:o})),Q(this.session.walletPublicKey));this.gateway.send(a,this.session.walletPublicKey,e.method).catch(i),this.pendingRequests.set(o.toString(),n),t?.()}))}closeConnection(){this.closeGateways(),this.listeners=[],this.session=null,this.gateway=null}disconnect(){return r(this,void 0,void 0,function*(){return new Promise(e=>r(this,void 0,void 0,function*(){let t=!1,n=()=>{t=!0,this.removeBridgeAndSession().then(e)};try{yield this.sendRequest({method:"disconnect",params:[]},n)}catch(i){console.debug(i),t||this.removeBridgeAndSession().then(e)}}))})}listen(e){return this.listeners.push(e),()=>this.listeners=this.listeners.filter(t=>t!==e)}pause(){var e;(e=this.gateway)===null||e===void 0||e.pause(),this.pendingGateways.forEach(t=>t.pause())}unPause(){return r(this,void 0,void 0,function*(){let e=this.pendingGateways.map(t=>t.unPause());this.gateway&&e.push(this.gateway.unPause()),yield Promise.all(e)})}pendingGatewaysListener(e,t,n){return r(this,void 0,void 0,function*(){if(!this.pendingGateways.includes(e)){e.close();return}return this.closeGateways({except:e}),this.session.bridgeUrl=t,this.gateway=e,this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)),this.gateway.setListener(this.gatewayListener.bind(this)),this.gatewayListener(n)})}gatewayListener(e){return r(this,void 0,void 0,function*(){let t=JSON.parse(this.session.sessionCrypto.decrypt(F.decode(e.message).toUint8Array(),Q(e.from)));if(h("Wallet message received:",t),!("event"in t)){let i=t.id.toString(),o=this.pendingRequests.get(i);if(!o){h(`Response id ${i} doesn't match any request's id`);return}o(t),this.pendingRequests.delete(i);return}if(t.id!==void 0){let i=yield this.connectionStorage.getLastWalletEventId();if(i!==void 0&&t.id<=i){R(`Received event id (=${t.id}) must be greater than stored last wallet event id (=${i}) `);return}t.event!=="connect"&&(yield this.connectionStorage.storeLastWalletEventId(t.id))}let n=this.listeners;t.event==="connect"&&(yield this.updateSession(t,e.from)),t.event==="disconnect"&&(yield this.removeBridgeAndSession()),n.forEach(i=>i(t))})}gatewayErrorsListener(e){return r(this,void 0,void 0,function*(){throw new c(`Bridge error ${JSON.stringify(e)}`)})}updateSession(e,t){return r(this,void 0,void 0,function*(){this.session=Object.assign(Object.assign({},this.session),{walletPublicKey:t});let n=e.payload.items.find(o=>o.name==="ton_addr"),i=Object.assign(Object.assign({},e),{payload:Object.assign(Object.assign({},e.payload),{items:[n]})});yield this.connectionStorage.storeConnection({type:"http",session:this.session,lastWalletEventId:e.id,connectEvent:i,nextRpcRequestId:0})})}removeBridgeAndSession(){return r(this,void 0,void 0,function*(){this.closeConnection(),yield this.connectionStorage.removeConnection()})}generateUniversalLink(e,t){return re(e)?this.generateTGUniversalLink(e,t):this.generateRegularUniversalLink(e,t)}generateRegularUniversalLink(e,t){let n=new URL(e);return n.searchParams.append("v",ee.toString()),n.searchParams.append("id",this.session.sessionCrypto.sessionId),n.searchParams.append("r",JSON.stringify(t)),n.toString()}generateTGUniversalLink(e,t){let o="tonconnect-"+this.generateRegularUniversalLink("about:blank",t).split("?")[1].replaceAll(".","%2E").replaceAll("-","%2D").replaceAll("_","%5F").replaceAll("&","-").replaceAll("=","__").replaceAll("%","--"),a=new URL(e);return a.searchParams.append("startattach",o),a.toString()}closeGateways(e){var t;(t=this.gateway)===null||t===void 0||t.close(),this.pendingGateways.filter(n=>n!==e?.except).forEach(n=>n.close()),this.pendingGateways=[]}};function Y(s,e){return te(s,[e])}function te(s,e){return!s||typeof s!="object"?!1:e.every(t=>t in s)}function ce(s){try{return!Y(s,"tonconnect")||!Y(s.tonconnect,"walletInfo")?!1:te(s.tonconnect.walletInfo,["name","app_name","image","about_url","platforms"])}catch{return!1}}function H(){if(!(typeof globalThis>"u"))return globalThis}function le(){if(!(typeof document>"u"))return document}function de(){var s;let e=(s=H())===null||s===void 0?void 0:s.location.origin;return e?e+"/tonconnect-manifest.json":""}var u=class s{constructor(e,t){this.injectedWalletKey=t,this.type="injected",this.unsubscribeCallback=null,this.listenSubscriptions=!1,this.listeners=[];let n=s.window;if(!s.isWindowContainsWallet(n,t))throw new A;this.connectionStorage=new f(e),this.injectedWallet=n[t].tonconnect}static fromStorage(e){return r(this,void 0,void 0,function*(){let n=yield new f(e).getInjectedConnection();return new s(e,n.jsBridgeKey)})}static isWalletInjected(e){return s.isWindowContainsWallet(this.window,e)}static isInsideWalletBrowser(e){return s.isWindowContainsWallet(this.window,e)?this.window[e].tonconnect.isWalletBrowser:!1}static getCurrentlyInjectedWallets(){return this.window?Object.entries(this.window).filter(([t,n])=>ce(n)).map(([t,n])=>({name:n.tonconnect.walletInfo.name,appName:n.tonconnect.walletInfo.app_name,aboutUrl:n.tonconnect.walletInfo.about_url,imageUrl:n.tonconnect.walletInfo.image,tondns:n.tonconnect.walletInfo.tondns,jsBridgeKey:t,injected:!0,embedded:n.tonconnect.isWalletBrowser,platforms:n.tonconnect.walletInfo.platforms})):[]}static isWindowContainsWallet(e,t){return!!e&&t in e&&typeof e[t]=="object"&&"tonconnect"in e[t]}connect(e){this._connect(ee,e)}restoreConnection(){return r(this,void 0,void 0,function*(){try{h("Injected Provider restoring connection...");let e=yield this.injectedWallet.restoreConnection();h("Injected Provider restoring connection response",e),e.event==="connect"?(this.makeSubscriptions(),this.listeners.forEach(t=>t(e))):yield this.connectionStorage.removeConnection()}catch(e){yield this.connectionStorage.removeConnection(),console.error(e)}})}closeConnection(){this.listenSubscriptions&&this.injectedWallet.disconnect(),this.closeAllListeners()}disconnect(){return r(this,void 0,void 0,function*(){return new Promise(e=>{let t=()=>{this.closeAllListeners(),this.connectionStorage.removeConnection().then(e)};try{this.injectedWallet.disconnect(),t()}catch(n){h(n),this.sendRequest({method:"disconnect",params:[]},t)}})})}closeAllListeners(){var e;this.listenSubscriptions=!1,this.listeners=[],(e=this.unsubscribeCallback)===null||e===void 0||e.call(this)}listen(e){return this.listeners.push(e),()=>this.listeners=this.listeners.filter(t=>t!==e)}sendRequest(e,t){return r(this,void 0,void 0,function*(){let n=(yield this.connectionStorage.getNextRpcRequestId()).toString();yield this.connectionStorage.increaseNextRpcRequestId(),h("Send injected-bridge request:",Object.assign(Object.assign({},e),{id:n}));let i=this.injectedWallet.send(Object.assign(Object.assign({},e),{id:n}));return i.then(o=>h("Wallet message received:",o)),t?.(),i})}_connect(e,t){return r(this,void 0,void 0,function*(){try{h(`Injected Provider connect request: protocolVersion: ${e}, message:`,t);let n=yield this.injectedWallet.connect(e,t);h("Injected Provider connect response:",n),n.event==="connect"&&(yield this.updateSession(),this.makeSubscriptions()),this.listeners.forEach(i=>i(n))}catch(n){h(n);let i={event:"connect_error",payload:{code:0,message:n?.toString()}};this.listeners.forEach(o=>o(i))}})}makeSubscriptions(){this.listenSubscriptions=!0,this.unsubscribeCallback=this.injectedWallet.listen(e=>{h("Wallet message received:",e),this.listenSubscriptions&&this.listeners.forEach(t=>t(e)),e.event==="disconnect"&&this.disconnect()})}updateSession(){return this.connectionStorage.storeConnection({type:"injected",jsBridgeKey:this.injectedWalletKey,nextRpcRequestId:0})}};u.window=H();var $=class{constructor(){let e=H();if(!e?.localStorage)throw new q;this.window=e}getItem(e){return r(this,void 0,void 0,function*(){return Promise.resolve(this.window.localStorage.getItem(e))})}removeItem(e){return r(this,void 0,void 0,function*(){return this.window.localStorage.removeItem(e),Promise.resolve()})}setItem(e,t){return this.window.localStorage.setItem(e,t),Promise.resolve()}};function he(s){return pe(s)&&s.injected}function ue(s){return he(s)&&s.embedded}function pe(s){return"jsBridgeKey"in s}function Re(s){return"bridgeUrl"in s}function Ie(s){return"jsBridgeKey"in s}var ge=[{app_name:"tonkeeper",name:"Tonkeeper",image:"https://tonkeeper.com/assets/tonconnect-icon.png",tondns:"tonkeeper.ton",about_url:"https://tonkeeper.com",universal_url:"https://app.tonkeeper.com/ton-connect",bridge:[{type:"sse",url:"https://bridge.tonapi.io/bridge"},{type:"js",key:"tonkeeper"}],platforms:["ios","android","chrome","firefox"]},{app_name:"openmask",name:"OpenMask",image:"https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",about_url:"https://www.openmask.app/",bridge:[{type:"js",key:"openmask"}],platforms:["chrome"]},{app_name:"mytonwallet",name:"MyTonWallet",image:"https://mytonwallet.io/icon-256.png",about_url:"https://mytonwallet.io",universal_url:"https://connect.mytonwallet.org",bridge:[{type:"js",key:"mytonwallet"},{type:"sse",url:"https://tonconnectbridge.mytonwallet.org/bridge/"}],platforms:["chrome","windows","macos","linux"]},{app_name:"tonhub",name:"Tonhub",image:"https://tonhub.com/tonconnect_logo.png",about_url:"https://tonhub.com",universal_url:"https://tonhub.com/ton-connect",bridge:[{type:"js",key:"tonhub"},{type:"sse",url:"https://connect.tonhubapi.com/tonconnect"}],platforms:["ios","android"]},{app_name:"tonflow",name:"TonFlow",image:"https://tonflow.net/assets/images/tonflow_ico_192.png",about_url:"https://tonflow.net",bridge:[{type:"js",key:"tonflow"}],platforms:["chrome"]},{app_name:"dewallet",name:"DeWallet",image:"https://app.delabwallet.com/logo_black.png",about_url:"https://delabwallet.com",bridge:[{type:"js",key:"dewallet"}],platforms:["chrome"]},{app_name:"xtonwallet",name:"XTONWallet",image:"https://xtonwallet.com/assets/img/icon-256-back.png",about_url:"https://xtonwallet.com",bridge:[{type:"js",key:"xtonwallet"}],platforms:["chrome","firefox"]},{app_name:"tonwallet",name:"TON Wallet",image:"https://wallet.ton.org/assets/ui/qr-logo.png",about_url:"https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",bridge:[{type:"js",key:"tonwallet"}],platforms:["chrome"]}],b=class{constructor(e){this.walletsListCache=null,this.walletsListCacheCreationTimestamp=null,this.walletsListSource="https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets.json",e?.walletsListSource&&(this.walletsListSource=e.walletsListSource),e?.cacheTTLMs&&(this.cacheTTLMs=e.cacheTTLMs)}getWallets(){return r(this,void 0,void 0,function*(){return this.cacheTTLMs&&this.walletsListCacheCreationTimestamp&&Date.now()>this.walletsListCacheCreationTimestamp+this.cacheTTLMs&&(this.walletsListCache=null),this.walletsListCache||(this.walletsListCache=this.fetchWalletsList(),this.walletsListCache.then(()=>{this.walletsListCacheCreationTimestamp=Date.now()}).catch(()=>{this.walletsListCache=null,this.walletsListCacheCreationTimestamp=null})),this.walletsListCache})}getEmbeddedWallet(){return r(this,void 0,void 0,function*(){let t=(yield this.getWallets()).filter(ue);return t.length!==1?null:t[0]})}fetchWalletsList(){return r(this,void 0,void 0,function*(){let e=[];try{if(e=yield(yield fetch(this.walletsListSource)).json(),!Array.isArray(e))throw new K("Wrong wallets list format, wallets list must be an array.");let i=e.filter(o=>!this.isCorrectWalletConfigDTO(o));i.length&&(R(`Wallet(s) ${i.map(o=>o.name).join(", ")} config format is wrong. They were removed from the wallets list.`),e=e.filter(o=>this.isCorrectWalletConfigDTO(o)))}catch(n){R(n),e=ge}let t=[];try{t=u.getCurrentlyInjectedWallets()}catch(n){R(n)}return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(e),t)})}walletConfigDTOListToWalletConfigList(e){return e.map(t=>{let i={name:t.name,appName:t.app_name,imageUrl:t.image,aboutUrl:t.about_url,tondns:t.tondns,platforms:t.platforms};return t.bridge.forEach(o=>{if(o.type==="sse"&&(i.bridgeUrl=o.url,i.universalLink=t.universal_url,i.deepLink=t.deepLink),o.type==="js"){let a=o.key;i.jsBridgeKey=a,i.injected=u.isWalletInjected(a),i.embedded=u.isInsideWalletBrowser(a)}}),i})}mergeWalletsLists(e,t){return[...new Set(e.concat(t).map(i=>i.name)).values()].map(i=>{let o=e.find(d=>d.name===i),a=t.find(d=>d.name===i);return Object.assign(Object.assign({},o&&Object.assign({},o)),a&&Object.assign({},a))})}isCorrectWalletConfigDTO(e){if(!e||typeof e!="object")return!1;let t="name"in e,n="app_name"in e,i="image"in e,o="about_url"in e,a="platforms"in e;if(!t||!i||!o||!a||!n||!e.platforms||!Array.isArray(e.platforms)||!e.platforms.length||!("bridge"in e)||!Array.isArray(e.bridge)||!e.bridge.length)return!1;let d=e.bridge;if(d.some(l=>!l||typeof l!="object"||!("type"in l)))return!1;let y=d.find(l=>l.type==="sse");if(y&&(!("url"in y)||!y.url||!e.universal_url))return!1;let g=d.find(l=>l.type==="js");return!(g&&(!("key"in g)||!g.key))}},N=class s extends c{get info(){return"Wallet doesn't support requested feature method."}constructor(...e){super(...e),Object.setPrototypeOf(this,s.prototype)}};function fe(s,e){let t=s.includes("SendTransaction"),n=s.find(i=>i&&typeof i=="object"&&i.name==="SendTransaction");if(!t&&!n)throw new N("Wallet doesn't support SendTransaction feature.");if(n&&n.maxMessages!==void 0){if(n.maxMessages<e.requiredMessagesNumber)throw new N(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${n.maxMessages}, but ${e.requiredMessagesNumber} is required.`);return}ae("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.")}var S=class{constructor(e){if(this.walletsList=new b,this._wallet=null,this.provider=null,this.statusChangeSubscriptions=[],this.statusChangeErrorSubscriptions=[],this.dappSettings={manifestUrl:e?.manifestUrl||de(),storage:e?.storage||new $},this.walletsList=new b({walletsListSource:e?.walletsListSource,cacheTTLMs:e?.walletsListCacheTTLMs}),!this.dappSettings.manifestUrl)throw new k("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");this.bridgeConnectionStorage=new f(this.dappSettings.storage),e?.disableAutoPauseConnection||this.addWindowFocusAndBlurSubscriptions()}static getWallets(){return this.walletsList.getWallets()}get connected(){return this._wallet!==null}get account(){var e;return((e=this._wallet)===null||e===void 0?void 0:e.account)||null}get wallet(){return this._wallet}set wallet(e){this._wallet=e,this.statusChangeSubscriptions.forEach(t=>t(this._wallet))}getWallets(){return this.walletsList.getWallets()}onStatusChange(e,t){return this.statusChangeSubscriptions.push(e),t&&this.statusChangeErrorSubscriptions.push(t),()=>{this.statusChangeSubscriptions=this.statusChangeSubscriptions.filter(n=>n!==e),t&&(this.statusChangeErrorSubscriptions=this.statusChangeErrorSubscriptions.filter(n=>n!==t))}}connect(e,t){var n;if(this.connected)throw new U;return(n=this.provider)===null||n===void 0||n.closeConnection(),this.provider=this.createProvider(e),this.provider.connect(this.createConnectRequest(t))}restoreConnection(){return r(this,void 0,void 0,function*(){let[e,t]=yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(),this.walletsList.getEmbeddedWallet()]);try{switch(e){case"http":this.provider=yield P.fromStorage(this.dappSettings.storage);break;case"injected":this.provider=yield u.fromStorage(this.dappSettings.storage);break;default:if(t)this.provider=yield this.createProvider(t);else return}}catch{yield this.bridgeConnectionStorage.removeConnection(),this.provider=null;return}return this.provider.listen(this.walletEventsListener.bind(this)),this.provider.restoreConnection()})}sendTransaction(e){return r(this,void 0,void 0,function*(){this.checkConnection(),fe(this.wallet.device.features,{requiredMessagesNumber:e.messages.length});let{validUntil:t}=e,n=ne(e,["validUntil"]),i=e.from||this.account.address,o=e.network||this.account.chain,a=yield this.provider.sendRequest(O.convertToRpcRequest(Object.assign(Object.assign({},n),{valid_until:t,from:i,network:o})));return O.isError(a)?O.parseAndThrowError(a):O.convertFromRpcResponse(a)})}disconnect(){return r(this,void 0,void 0,function*(){if(!this.connected)throw new E;yield this.provider.disconnect(),this.onWalletDisconnected()})}pauseConnection(){var e;((e=this.provider)===null||e===void 0?void 0:e.type)==="http"&&this.provider.pause()}unPauseConnection(){var e;return((e=this.provider)===null||e===void 0?void 0:e.type)!=="http"?Promise.resolve():this.provider.unPause()}addWindowFocusAndBlurSubscriptions(){let e=le();if(e)try{e.addEventListener("visibilitychange",()=>{e.hidden?this.pauseConnection():this.unPauseConnection()})}catch(t){console.error("Cannot subscribe to the document.visibilitychange: ",t)}}createProvider(e){let t;return!Array.isArray(e)&&se(e)?t=new u(this.dappSettings.storage,e.jsBridgeKey):t=new P(this.dappSettings.storage,e),t.listen(this.walletEventsListener.bind(this)),t}walletEventsListener(e){switch(e.event){case"connect":this.onWalletConnected(e.payload);break;case"connect_error":this.onWalletConnectError(e.payload);break;case"disconnect":this.onWalletDisconnected()}}onWalletConnected(e){let t=e.items.find(o=>o.name==="ton_addr"),n=e.items.find(o=>o.name==="ton_proof");if(!t)throw new c("ton_addr connection item was not found");let i={device:e.device,provider:this.provider.type,account:{address:t.address,chain:t.network,walletStateInit:t.walletStateInit,publicKey:t.publicKey}};n&&(i.connectItems={tonProof:n}),this.wallet=i}onWalletConnectError(e){let t=ie.parseError(e);if(this.statusChangeErrorSubscriptions.forEach(n=>n(t)),console.debug(t),t instanceof j||t instanceof I)throw console.error(t),t}onWalletDisconnected(){this.wallet=null}checkConnection(){if(!this.connected)throw new E}createConnectRequest(e){let t=[{name:"ton_addr"}];return e?.tonProof&&t.push({name:"ton_proof",payload:e.tonProof}),{manifestUrl:this.dappSettings.manifestUrl,items:t}}};S.walletsList=new b;S.isWalletInjected=s=>u.isWalletInjected(s);S.isInsideWalletBrowser=s=>u.isInsideWalletBrowser(s);var we=17,me=128;function je(s,e=!1){let{wc:t,hex:n}=ye(s),i=we;e&&(i|=me);let o=new Int8Array(34);o[0]=i,o[1]=t,o.set(n,2);let a=new Uint8Array(36);return a.set(o),a.set(ve(o),34),F.encode(a).replace(/\+/g,"-").replace(/\//g,"_")}function ye(s){if(!s.includes(":"))throw new m(`Wrong address ${s}. Address must include ":".`);let e=s.split(":");if(e.length!==2)throw new m(`Wrong address ${s}. Address must include ":" only once.`);let t=parseInt(e[0]);if(t!==0&&t!==-1)throw new m(`Wrong address ${s}. WC must be eq 0 or -1, but ${t} received.`);let n=e[1];if(n?.length!==64)throw new m(`Wrong address ${s}. Hex part must be 64bytes length, but ${n?.length} received.`);return{wc:t,hex:be(n)}}function ve(s){let t=0,n=new Uint8Array(s.length+2);n.set(s);for(let i of n){let o=128;for(;o>0;)t<<=1,i&o&&(t+=1),o>>=1,t>65535&&(t&=65535,t^=4129)}return new Uint8Array([Math.floor(t/256),t%256])}var J={};for(let s=0;s<=255;s++){let e=s.toString(16);e.length<2&&(e="0"+e),J[e]=s}function be(s){s=s.toLowerCase();let e=s.length;if(e%2!==0)throw new W("Hex string must have length a multiple of 2: "+s);let t=e/2,n=new Uint8Array(t);for(let i=0;i<t;i++){let o=i*2,a=s.substring(o,o+2);if(!J.hasOwnProperty(a))throw new W("Invalid hex character: "+a);n[i]=J[a]}return n}export{_ as BadRequestError,_e as CHAIN,Te as CONNECT_ITEM_ERROR_CODES,K as FetchWalletsError,q as LocalstorageNotFoundError,W as ParseHexError,S as TonConnect,c as TonConnectError,T as UnknownAppError,p as UnknownError,L as UserRejectsError,U as WalletAlreadyConnectedError,E as WalletNotConnectedError,A as WalletNotInjectedError,b as WalletsListManager,m as WrongAddressError,S as default,re as isTelegramUrl,ue as isWalletInfoCurrentlyEmbedded,he as isWalletInfoCurrentlyInjected,pe as isWalletInfoInjectable,Ie as isWalletInfoInjected,Re as isWalletInfoRemote,je as toUserFriendlyAddress};
/*! Bundled license information:

@tonconnect/sdk/lib/esm/index.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=sdk.mjs.map