/* esm.sh - @tonconnect/protocol@2.3.0 */
import __Process$ from "node:process";
import o from"/tweetnacl-util@^0.15.1?target=denonext";import s from"/tweetnacl@^1.0.3?target=denonext";var y;(function(e){e[e.UNKNOWN_ERROR=0]="UNKNOWN_ERROR",e[e.BAD_REQUEST_ERROR=1]="BAD_REQUEST_ERROR",e[e.MANIFEST_NOT_FOUND_ERROR=2]="MANIFEST_NOT_FOUND_ERROR",e[e.MANIFEST_CONTENT_ERROR=3]="MANIFEST_CONTENT_ERROR",e[e.UNKNOWN_APP_ERROR=100]="UNKNOWN_APP_ERROR",e[e.USER_REJECTS_ERROR=300]="USER_REJECTS_ERROR",e[e.METHOD_NOT_SUPPORTED=400]="METHOD_NOT_SUPPORTED"})(y||(y={}));var a;(function(e){e[e.UNKNOWN_ERROR=0]="UNKNOWN_ERROR",e[e.METHOD_NOT_SUPPORTED=400]="METHOD_NOT_SUPPORTED"})(a||(a={}));var u;(function(e){e[e.UNKNOWN_ERROR=0]="UNKNOWN_ERROR",e[e.BAD_REQUEST_ERROR=1]="BAD_REQUEST_ERROR",e[e.UNKNOWN_APP_ERROR=100]="UNKNOWN_APP_ERROR",e[e.USER_REJECTS_ERROR=300]="USER_REJECTS_ERROR",e[e.METHOD_NOT_SUPPORTED=400]="METHOD_NOT_SUPPORTED"})(u||(u={}));var P;(function(e){e[e.UNKNOWN_ERROR=0]="UNKNOWN_ERROR",e[e.BAD_REQUEST_ERROR=1]="BAD_REQUEST_ERROR",e[e.UNKNOWN_APP_ERROR=100]="UNKNOWN_APP_ERROR",e[e.USER_REJECTS_ERROR=300]="USER_REJECTS_ERROR",e[e.METHOD_NOT_SUPPORTED=400]="METHOD_NOT_SUPPORTED"})(P||(P={}));var d;(function(e){e[e.UNKNOWN_ERROR=0]="UNKNOWN_ERROR",e[e.BAD_REQUEST_ERROR=1]="BAD_REQUEST_ERROR",e[e.UNKNOWN_APP_ERROR=100]="UNKNOWN_APP_ERROR",e[e.METHOD_NOT_SUPPORTED=400]="METHOD_NOT_SUPPORTED"})(d||(d={}));var K;(function(e){e.MAINNET="-239",e.TESTNET="-3"})(K||(K={}));function h(e,t){let n=o.encodeBase64(e);return t?encodeURIComponent(n):n}function l(e,t){return t&&(e=decodeURIComponent(e)),o.decodeBase64(e)}function R(e,t=!1){let n;return e instanceof Uint8Array?n=e:(typeof e!="string"&&(e=JSON.stringify(e)),n=o.decodeUTF8(e)),h(n,t)}function g(e,t=!1){let n=l(e,t);return{toString(){return o.encodeUTF8(n)},toObject(){try{return JSON.parse(o.encodeUTF8(n))}catch{return null}},toUint8Array(){return n}}}var k={encode:R,decode:g};function W(e,t){let n=new Uint8Array(e.length+t.length);return n.set(e),n.set(t,e.length),n}function M(e,t){if(t>=e.length)throw new Error("Index is out of buffer");let n=e.slice(0,t),r=e.slice(t);return[n,r]}function U(e){let t="";return e.forEach(n=>{t+=("0"+(n&255).toString(16)).slice(-2)}),t}function f(e){if(e.length%2!==0)throw new Error(`Cannot convert ${e} to bytesArray`);let t=new Uint8Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=parseInt(e.slice(n,n+2),16);return t}function F(){return typeof __Process$<"u"&&__Process$.versions!=null&&__Process$.versions.node!=null}var p=class{constructor(t){this.nonceLength=24,this.keyPair=t?this.createKeypairFromString(t):this.createKeypair(),this.sessionId=U(this.keyPair.publicKey)}createKeypair(){return s.box.keyPair()}createKeypairFromString(t){return{publicKey:f(t.publicKey),secretKey:f(t.secretKey)}}createNonce(){return s.randomBytes(this.nonceLength)}encrypt(t,n){let r=new TextEncoder().encode(t),c=this.createNonce(),i=s.box(r,c,n,this.keyPair.secretKey);return W(c,i)}decrypt(t,n){let[r,c]=M(t,this.nonceLength),i=s.box.open(c,r,n,this.keyPair.secretKey);if(!i)throw new Error(`Decryption error: 
 message: ${t.toString()} 
 sender pubkey: ${n.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);return new TextDecoder().decode(i)}stringifyKeypair(){return{publicKey:U(this.keyPair.publicKey),secretKey:U(this.keyPair.secretKey)}}};export{k as Base64,K as CHAIN,y as CONNECT_EVENT_ERROR_CODES,a as CONNECT_ITEM_ERROR_CODES,d as DISCONNECT_ERROR_CODES,u as SEND_TRANSACTION_ERROR_CODES,P as SIGN_DATA_ERROR_CODES,p as SessionCrypto,W as concatUint8Arrays,f as hexToByteArray,F as isNode,M as splitToUint8Arrays,U as toHexString};
//# sourceMappingURL=protocol.mjs.map