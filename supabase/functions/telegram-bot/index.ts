/* eslint-disable no-case-declarations */
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const BOT_TOKEN = Deno.env.get("TELEGRAM_BOT_TOKEN");
const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY");
const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

console.log("üöÄ Bot starting with environment check...");
console.log("BOT_TOKEN exists:", !!BOT_TOKEN);
console.log("SUPABASE_URL exists:", !!SUPABASE_URL);
console.log("SUPABASE_SERVICE_ROLE_KEY exists:", !!SUPABASE_SERVICE_ROLE_KEY);

if (!BOT_TOKEN || !SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  console.error("‚ùå Missing required environment variables");
  throw new Error("Missing required environment variables");
}

const supabaseAdmin = createClient(SUPABASE_URL!, SUPABASE_SERVICE_ROLE_KEY!, {
  auth: { persistSession: false },
});

// Admin user IDs - including the user who's testing
const ADMIN_USER_IDS = new Set(["225513686"]);

// User sessions for features
const userSessions = new Map();
const activeBotSessions = new Map(); // Track bot sessions

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

// Bot startup time for status tracking
const BOT_START_TIME = new Date();
console.log("üïê Bot started at:", BOT_START_TIME.toISOString());

// Session Management Functions
async function startBotSession(telegramUserId: string, userInfo: any = {}): Promise<string> {
  try {
    console.log(`üîÑ Starting session for user: ${telegramUserId}`);
    
    // End any existing active sessions
    await endBotSession(telegramUserId);
    
    // Create new session
    const { data, error } = await supabaseAdmin
      .from('bot_sessions')
      .insert({
        telegram_user_id: telegramUserId,
        session_start: new Date().toISOString(),
        session_data: userInfo,
        activity_count: 1
      })
      .select()
      .single();

    if (error) {
      console.error('‚ùå Error creating session:', error);
      return '';
    }

    // Store in memory for quick access
    activeBotSessions.set(telegramUserId, {
      sessionId: data.id,
      startTime: new Date(),
      activityCount: 1
    });

    console.log(`‚úÖ Session started for user ${telegramUserId}, session ID: ${data.id}`);
    return data.id;
  } catch (error) {
    console.error('üö® Exception starting session:', error);
    return '';
  }
}

async function updateBotSession(telegramUserId: string, activityData: any = {}): Promise<void> {
  try {
    const session = activeBotSessions.get(telegramUserId);
    if (!session) {
      // Start new session if none exists
      await startBotSession(telegramUserId, activityData);
      return;
    }

    session.activityCount++;
    session.lastActivity = new Date();

    // Update in database
    await supabaseAdmin
      .from('bot_sessions')
      .update({
        activity_count: session.activityCount,
        session_data: activityData,
        updated_at: new Date().toISOString()
      })
      .eq('id', session.sessionId);

    console.log(`üìä Session updated for user ${telegramUserId}, activities: ${session.activityCount}`);
  } catch (error) {
    console.error('üö® Error updating session:', error);
  }
}

async function endBotSession(telegramUserId: string): Promise<void> {
  try {
    const session = activeBotSessions.get(telegramUserId);
    if (!session) return;

    const endTime = new Date();
    const durationMinutes = Math.floor((endTime.getTime() - session.startTime.getTime()) / 1000 / 60);

    // Update database
    await supabaseAdmin
      .from('bot_sessions')
      .update({
        session_end: endTime.toISOString(),
        duration_minutes: durationMinutes,
        updated_at: endTime.toISOString()
      })
      .eq('id', session.sessionId);

    // Remove from memory
    activeBotSessions.delete(telegramUserId);

    console.log(`‚è∞ Session ended for user ${telegramUserId}, duration: ${durationMinutes} minutes`);
  } catch (error) {
    console.error('üö® Error ending session:', error);
  }
}

// Database utility functions
async function getBotContent(contentKey: string): Promise<string | null> {
  try {
    console.log(`üìÑ Fetching content: ${contentKey}`);
    const { data, error } = await supabaseAdmin
      .from('bot_content')
      .select('content_value')
      .eq('content_key', contentKey)
      .eq('is_active', true)
      .single();

    if (error) {
      console.error(`‚ùå Error fetching content for ${contentKey}:`, error);
      return null;
    }

    console.log(`‚úÖ Content fetched for ${contentKey}`);
    return data?.content_value || null;
  } catch (error) {
    console.error(`üö® Exception in getBotContent for ${contentKey}:`, error);
    return null;
  }
}

async function setBotContent(contentKey: string, contentValue: string, adminId: string): Promise<boolean> {
  try {
    console.log(`üìù Setting content: ${contentKey} by admin: ${adminId}`);
    const { error } = await supabaseAdmin
      .from('bot_content')
      .upsert({
        content_key: contentKey,
        content_value: contentValue,
        last_modified_by: adminId,
        updated_at: new Date().toISOString()
      });

    if (!error) {
      await logAdminAction(adminId, 'content_update', `Updated content: ${contentKey}`, 'bot_content');
      console.log(`‚úÖ Content updated: ${contentKey}`);
    } else {
      console.error(`‚ùå Error setting content: ${contentKey}`, error);
    }

    return !error;
  } catch (error) {
    console.error('üö® Exception in setBotContent:', error);
    return false;
  }
}

async function getBotSetting(settingKey: string): Promise<string | null> {
  try {
    console.log(`‚öôÔ∏è Fetching setting: ${settingKey}`);
    const { data, error } = await supabaseAdmin
      .from('bot_settings')
      .select('setting_value')
      .eq('setting_key', settingKey)
      .eq('is_active', true)
      .single();

    if (error && error.code !== 'PGRST116') { // PGRST116 is "not found"
      console.error(`‚ùå Error fetching setting ${settingKey}:`, error);
    }

    return data?.setting_value || null;
  } catch (error) {
    console.error(`üö® Exception fetching setting ${settingKey}:`, error);
    return null;
  }
}

async function setBotSetting(settingKey: string, settingValue: string, adminId: string): Promise<boolean> {
  try {
    console.log(`‚öôÔ∏è Setting bot setting: ${settingKey} = ${settingValue}`);
    const { error } = await supabaseAdmin
      .from('bot_settings')
      .upsert({
        setting_key: settingKey,
        setting_value: settingValue,
        updated_at: new Date().toISOString()
      });

    if (!error) {
      await logAdminAction(adminId, 'setting_update', `Updated setting: ${settingKey}`, 'bot_settings');
      console.log(`‚úÖ Setting updated: ${settingKey}`);
    } else {
      console.error(`‚ùå Error setting: ${settingKey}`, error);
    }

    return !error;
  } catch (error) {
    console.error('üö® Exception in setBotSetting:', error);
    return false;
  }
}

async function logAdminAction(
  adminId: string,
  actionType: string,
  description: string,
  affectedTable?: string,
  affectedRecordId?: string,
  oldValues?: any,
  newValues?: any
): Promise<void> {
  try {
    await supabaseAdmin
      .from('admin_logs')
      .insert({
        admin_telegram_id: adminId,
        action_type: actionType,
        action_description: description,
        affected_table: affectedTable,
        affected_record_id: affectedRecordId,
        old_values: oldValues,
        new_values: newValues
      });
    console.log(`üìã Admin action logged: ${actionType} by ${adminId}`);
  } catch (error) {
    console.error('üö® Error logging admin action:', error);
  }
}

// Auto-response functions from Supabase tables
async function getAutoReply(contentKey: string, variables: Record<string, string> = {}): Promise<string | null> {
  try {
    console.log(`üì± Getting auto reply: ${contentKey}`);
    const content = await getBotContent(contentKey);
    if (!content) {
      console.log(`‚ùå No auto reply found for: ${contentKey}`);
      return null;
    }
    
    return formatContent(content, variables);
  } catch (error) {
    console.error(`üö® Error getting auto reply ${contentKey}:`, error);
    return null;
  }
}

async function handleUnknownCommand(chatId: number, userId: string, command: string): Promise<void> {
  console.log(`‚ùì Unknown command from ${userId}: ${command}`);
  
  const autoReply = await getAutoReply('auto_reply_unknown');
  const message = autoReply || `ü§î I didn't understand "${command}". Try /start for the main menu!`;
  
  await sendMessage(chatId, message);
  
  // Log unknown command for analytics
  await supabaseAdmin
    .from('user_interactions')
    .insert({
      telegram_user_id: userId,
      interaction_type: 'unknown_command',
      interaction_data: { command, timestamp: new Date().toISOString() }
    });
}

async function handleHelpCommand(chatId: number, userId: string, firstName: string): Promise<void> {
  console.log(`‚ùì Help command from ${userId}`);
  
  const autoReply = await getAutoReply('auto_reply_help', { firstName });
  const message = autoReply || `‚ùì **Need Help?**\n\nü§ñ Use /start for the main menu\nüîë Admins can use /admin\n\nüõü Contact: @DynamicCapital_Support`;
  
  await sendMessage(chatId, message);
}

function formatContent(content: string, variables: Record<string, string>): string {
  let formattedContent = content;
  
  Object.entries(variables).forEach(([key, value]) => {
    const placeholder = `{${key}}`;
    formattedContent = formattedContent.replace(new RegExp(placeholder, 'g'), value || '');
  });
  
  return formattedContent;
}

// Load additional admin IDs from the database
async function refreshAdminIds() {
  try {
    console.log("üîë Loading admin IDs from database...");
    const { data, error } = await supabaseAdmin
      .from('bot_users')
      .select('telegram_id')
      .eq('is_admin', true);

    if (error) {
      console.error('‚ùå Failed to load admin IDs:', error);
      return;
    }

    let addedCount = 0;
    data?.forEach((row: { telegram_id: string | number }) => {
      const id = row.telegram_id.toString();
      if (!ADMIN_USER_IDS.has(id)) {
        ADMIN_USER_IDS.add(id);
        addedCount++;
      }
    });
    
    console.log(`‚úÖ Loaded ${data?.length || 0} admin IDs from database (${addedCount} new)`);
    console.log(`üîë Total admin IDs: ${ADMIN_USER_IDS.size}`);
  } catch (error) {
    console.error('üö® Exception loading admin IDs:', error);
  }
}

// Initialize admin IDs
await refreshAdminIds();

function isAdmin(userId: string): boolean {
  const result = ADMIN_USER_IDS.has(userId);
  console.log(`üîê Admin check for ${userId}: ${result}`);
  return result;
}

function getUserSession(userId: string | number) {
  const userIdStr = userId.toString();
  if (!userSessions.has(userIdStr)) {
    userSessions.set(userIdStr, { awaitingInput: null });
  }
  return userSessions.get(userIdStr);
}

async function sendMessage(
  chatId: number,
  text: string,
  replyMarkup?: Record<string, unknown>
) {
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
  const payload = {
    chat_id: chatId,
    text: text,
    reply_markup: replyMarkup,
    parse_mode: "Markdown"
  };

  try {
    console.log(`üì§ Sending message to ${chatId}: ${text.substring(0, 100)}...`);
    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorData = await response.text();
      console.error("‚ùå Telegram API error:", errorData);
      return null;
    }

    const result = await response.json();
    console.log(`‚úÖ Message sent successfully to ${chatId}`);

    // Auto-delete messages in groups after 30 seconds
    if (result.ok && result.result) {
      const messageId = result.result.message_id;
      const chatType = await getChatType(chatId);
      
      // Check if it's a group or supergroup
      if (chatType === 'group' || chatType === 'supergroup') {
        console.log(`‚è∞ Scheduling auto-deletion for message ${messageId} in chat ${chatId}`);
        
        // Schedule deletion after 30 seconds
        setTimeout(async () => {
          try {
            console.log(`üóëÔ∏è Auto-deleting message ${messageId} from chat ${chatId}`);
            await deleteMessage(chatId, messageId);
          } catch (error) {
            console.error(`‚ùå Failed to auto-delete message ${messageId}:`, error);
          }
        }, 30000); // 30 seconds
      }
    }

    return result;
  } catch (error) {
    console.error("üö® Error sending message:", error);
    return null;
  }
}

// Function to delete a specific message
async function deleteMessage(chatId: number, messageId: number): Promise<boolean> {
  try {
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/deleteMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        message_id: messageId
      })
    });

    const result = await response.json();

    if (!response.ok) {
      console.error('‚ùå Failed to delete message:', result);
      return false;
    }

    console.log(`‚úÖ Message ${messageId} deleted from chat ${chatId}`);
    return true;
  } catch (error) {
    console.error('üö® Error deleting message:', error);
    return false;
  }
}

// Function to get chat type (private, group, supergroup, channel)
async function getChatType(chatId: number): Promise<string> {
  try {
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getChat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: chatId })
    });

    const result = await response.json();

    if (result.ok && result.result) {
      return result.result.type;
    }

    return 'unknown';
  } catch (error) {
    console.error('üö® Error getting chat type:', error);
    return 'unknown';
  }
}

// Enhanced content management functions
async function getWelcomeMessage(firstName: string): Promise<string> {
  const template = await getBotContent('welcome_message');
  if (!template) {
    return `üöÄ *Welcome to Dynamic Capital VIP, ${firstName}!*\n\nWe're here to help you level up your trading with:\n\n‚Ä¢ üîî Quick market updates\n‚Ä¢ üìà Beginner-friendly tips\n‚Ä¢ üéì Easy learning resources\n\nReady to get started? Pick an option below üëá`;
  }
  return formatContent(template, { firstName });
}

async function getVipPackages(): Promise<any[]> {
  try {
    console.log("üíé Fetching VIP packages...");
    const { data, error } = await supabaseAdmin
      .from('subscription_plans')
      .select('*')
      .order('price', { ascending: true });

    if (error) {
      console.error('‚ùå Error fetching VIP packages:', error);
      return [];
    }

    console.log(`‚úÖ Fetched ${data?.length || 0} VIP packages`);
    return data || [];
  } catch (error) {
    console.error('üö® Exception fetching VIP packages:', error);
    return [];
  }
}

// Enhanced VIP packages display with better formatting
async function getFormattedVipPackages(): Promise<string> {
  const packages = await getVipPackages();
  
  if (packages.length === 0) {
    return "üíé *VIP Membership Packages*\n\n‚ùå No packages available at the moment.";
  }

  let message = `üíé *VIP Membership Packages*\n\nüöÄ *Unlock Premium Trading Success!*\n\n`;
  
  packages.forEach((pkg, index) => {
    const discount = pkg.duration_months >= 12 ? 'üî• BEST VALUE' : 
                    pkg.duration_months >= 6 ? '‚≠ê POPULAR' :
                    pkg.duration_months >= 3 ? 'üí´ SAVE MORE' : 'üéØ STARTER';
    
    const monthlyEquivalent = pkg.duration_months > 0 ? 
      `($${(pkg.price / pkg.duration_months).toFixed(0)}/month)` : '';
    
    const savingsInfo = pkg.duration_months >= 12 ? 'üí∞ Save 35%' :
                       pkg.duration_months >= 6 ? 'üí∞ Save 20%' :
                       pkg.duration_months >= 3 ? 'üí∞ Save 15%' : '';

    message += `${index + 1}. **${pkg.name}** ${discount}\n`;
    message += `   üí∞ **${pkg.currency} ${pkg.price}**`;
    
    if (pkg.is_lifetime) {
      message += ` - *Lifetime Access*\n`;
    } else {
      message += `/${pkg.duration_months}mo ${monthlyEquivalent}\n`;
      if (savingsInfo) message += `   ${savingsInfo}\n`;
    }
    
    message += `   ‚ú® **Features:**\n`;
    if (pkg.features && Array.isArray(pkg.features)) {
      pkg.features.forEach(feature => {
        message += `      ‚Ä¢ ${feature}\n`;
      });
    }
    
    if (pkg.is_lifetime) {
      message += `      ‚Ä¢ üåü All future programs included\n`;
      message += `      ‚Ä¢ üîê Exclusive lifetime member content\n`;
    }
    
    message += `\n`;
  });

  message += `üéÅ *Special Benefits:*\n`;
  message += `‚Ä¢ üìà Real-time trading signals\n`;
  message += `‚Ä¢ üèÜ VIP community access\n`;
  message += `‚Ä¢ üìä Daily market analysis\n`;
  message += `‚Ä¢ üéì Educational resources\n`;
  message += `‚Ä¢ üí¨ Direct mentor support\n\n`;
  
  message += `‚úÖ *Ready to level up your trading?*\nSelect a package below to get started!`;

  return message;
}

// Enhanced keyboard generators
async function getMainMenuKeyboard(): Promise<any> {
  return {
    inline_keyboard: [
      [
        { text: "üíé VIP Packages", callback_data: "view_vip_packages" },
        { text: "üéì Education", callback_data: "view_education" }
      ],
      [
        { text: "üè¢ About Us", callback_data: "about_us" },
        { text: "üõü Support", callback_data: "support" }
      ],
      [
        { text: "üí∞ Promotions", callback_data: "view_promotions" },
        { text: "‚ùì FAQ", callback_data: "faq" }
      ],
      [
        { text: "üìã Terms", callback_data: "terms" }
      ]
    ]
  };
}

async function getVipPackagesKeyboard(): Promise<any> {
  const packages = await getVipPackages();
  const keyboard = [];
  
  for (const pkg of packages) {
    const discount = pkg.duration_months >= 12 ? ' üî•' : 
                    pkg.duration_months >= 6 ? ' ‚≠ê' :
                    pkg.duration_months >= 3 ? ' üí´' : '';
    
    const price = pkg.is_lifetime ? `$${pkg.price} Lifetime` : `$${pkg.price}/${pkg.duration_months}mo`;
    
    keyboard.push([{
      text: `üíé ${pkg.name}${discount} - ${price}`,
      callback_data: `select_vip_${pkg.id}`
    }]);
  }
  
  keyboard.push([
    { text: "üéÅ View Promotions", callback_data: "view_promotions" },
    { text: "‚ùì Have Questions?", callback_data: "contact_support" }
  ]);
  keyboard.push([{ text: "üîô Back to Main Menu", callback_data: "back_main" }]);
  
  return { inline_keyboard: keyboard };
}

// Enhanced admin management functions
async function handleAdminDashboard(chatId: number, userId: string): Promise<void> {
  console.log(`üîê Admin dashboard access attempt by: ${userId}`);
  
  if (!isAdmin(userId)) {
    console.log(`‚ùå Access denied for user: ${userId}`);
    await sendMessage(chatId, "‚ùå Access denied. Admin privileges required.");
    return;
  }

  console.log(`‚úÖ Admin access granted for: ${userId}`);

  try {
    // Get comprehensive stats for dashboard
    const [userCount, vipCount, planCount, promoCount, sessionCount] = await Promise.all([
      supabaseAdmin.from('bot_users').select('count', { count: 'exact' }),
      supabaseAdmin.from('bot_users').select('count', { count: 'exact' }).eq('is_vip', true),
      supabaseAdmin.from('subscription_plans').select('count', { count: 'exact' }),
      supabaseAdmin.from('promotions').select('count', { count: 'exact' }).eq('is_active', true),
      supabaseAdmin.from('bot_sessions').select('count', { count: 'exact' }).is('session_end', null)
    ]);

    const uptime = Math.floor((Date.now() - BOT_START_TIME.getTime()) / 1000 / 60); // minutes
    const botStatus = "üü¢ Online & Optimized";

    const adminMessage = `üîê *Enhanced Admin Dashboard*

üìä *System Status:* ${botStatus}
üë§ *Admin:* ${userId}
üïê *Uptime:* ${uptime} minutes
üïê *Last Updated:* ${new Date().toLocaleString()}

üìà *Live Statistics:*
‚Ä¢ üë• Total Users: ${userCount.count || 0}
‚Ä¢ üíé VIP Members: ${vipCount.count || 0}
‚Ä¢ üì¶ Active Plans: ${planCount.count || 0}
‚Ä¢ üéÅ Active Promos: ${promoCount.count || 0}
‚Ä¢ üí¨ Active Sessions: ${sessionCount.count || 0}
‚Ä¢ üîó Memory Sessions: ${activeBotSessions.size}

üöÄ *Management Tools:*
‚Ä¢ üîÑ **Bot Control** - Status, refresh, restart
‚Ä¢ üë• **User Management** - Admins, VIP, analytics
‚Ä¢ üì¶ **Package Control** - VIP & education packages  
‚Ä¢ üí∞ **Promotions Hub** - Discounts & campaigns
‚Ä¢ üí¨ **Content Editor** - Messages & UI text
‚Ä¢ ‚öôÔ∏è **Bot Settings** - Configuration & behavior
‚Ä¢ üìà **Analytics Center** - Reports & insights
‚Ä¢ üì¢ **Broadcasting** - Mass communication
‚Ä¢ üîß **System Tools** - Maintenance & utilities`;

    const adminKeyboard = {
      inline_keyboard: [
        [
          { text: "üîÑ Bot Control", callback_data: "bot_control" },
          { text: "üìä Bot Status", callback_data: "bot_status" }
        ],
        [
          { text: "üë• Users", callback_data: "admin_users" },
          { text: "üì¶ Packages", callback_data: "admin_packages" }
        ],
        [
          { text: "üí∞ Promotions", callback_data: "admin_promos" },
          { text: "üí¨ Content", callback_data: "admin_content" }
        ],
        [
          { text: "‚öôÔ∏è Settings", callback_data: "admin_settings" },
          { text: "üìà Analytics", callback_data: "admin_analytics" }
        ],
        [
          { text: "üì¢ Broadcast", callback_data: "admin_broadcast" },
          { text: "üîß Tools", callback_data: "admin_tools" }
        ],
        [
          { text: "üí¨ Sessions", callback_data: "view_sessions" },
          { text: "üîÑ Refresh", callback_data: "admin_dashboard" }
        ]
      ]
    };

    await sendMessage(chatId, adminMessage, adminKeyboard);
    await logAdminAction(userId, 'dashboard_access', 'Accessed admin dashboard');
    
    console.log(`‚úÖ Admin dashboard sent to: ${userId}`);
  } catch (error) {
    console.error('üö® Error in admin dashboard:', error);
    await sendMessage(chatId, `‚ùå Error loading admin dashboard: ${error.message}`);
  }
}

// Session management for admins
async function handleViewSessions(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  try {
    console.log(`üìä Viewing sessions for admin: ${userId}`);
    
    // Get active sessions
    const { data: activeSessions, error: activeError } = await supabaseAdmin
      .from('bot_sessions')
      .select('telegram_user_id, session_start, activity_count, session_data')
      .is('session_end', null)
      .order('session_start', { ascending: false })
      .limit(10);

    // Get recent completed sessions
    const { data: recentSessions, error: recentError } = await supabaseAdmin
      .from('bot_sessions')
      .select('telegram_user_id, session_start, session_end, duration_minutes, activity_count')
      .not('session_end', 'is', null)
      .order('session_end', { ascending: false })
      .limit(5);

    if (activeError || recentError) {
      throw new Error('Database error fetching sessions');
    }

    let sessionMessage = `üí¨ *Session Management*\n\n`;
    
    sessionMessage += `üü¢ *Active Sessions (${activeSessions?.length || 0}):*\n`;
    if (activeSessions && activeSessions.length > 0) {
      activeSessions.forEach((session, index) => {
        const startTime = new Date(session.session_start);
        const duration = Math.floor((Date.now() - startTime.getTime()) / 1000 / 60);
        sessionMessage += `${index + 1}. User: ${session.telegram_user_id}\n`;
        sessionMessage += `   üìÖ Started: ${startTime.toLocaleString()}\n`;
        sessionMessage += `   ‚è±Ô∏è Duration: ${duration}min\n`;
        sessionMessage += `   üìä Activities: ${session.activity_count}\n\n`;
      });
    } else {
      sessionMessage += `   No active sessions\n\n`;
    }

    sessionMessage += `üìã *Recent Completed (${recentSessions?.length || 0}):*\n`;
    if (recentSessions && recentSessions.length > 0) {
      recentSessions.forEach((session, index) => {
        sessionMessage += `${index + 1}. User: ${session.telegram_user_id}\n`;
        sessionMessage += `   ‚è±Ô∏è Duration: ${session.duration_minutes || 0}min\n`;
        sessionMessage += `   üìä Activities: ${session.activity_count}\n\n`;
      });
    } else {
      sessionMessage += `   No recent sessions\n\n`;
    }

    sessionMessage += `üîó *Memory Sessions:* ${activeBotSessions.size}`;

    const sessionKeyboard = {
      inline_keyboard: [
        [
          { text: "üßπ Clean Old Sessions", callback_data: "clean_old_sessions" },
          { text: "üìä Session Analytics", callback_data: "session_analytics" }
        ],
        [
          { text: "üîÑ Refresh", callback_data: "view_sessions" },
          { text: "üîô Back to Admin", callback_data: "admin_dashboard" }
        ]
      ]
    };

    await sendMessage(chatId, sessionMessage, sessionKeyboard);
  } catch (error) {
    console.error('üö® Error viewing sessions:', error);
    await sendMessage(chatId, `‚ùå Error fetching sessions: ${error.message}`);
  }
}

// Bot Control Functions
async function handleBotControl(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const controlMessage = `üîÑ *Bot Control Center*

üöÄ *Available Actions:*
‚Ä¢ üîÑ **Refresh Bot** - Reload configurations & admin IDs
‚Ä¢ üìä **Check Status** - System health & performance
‚Ä¢ üßπ **Clean Cache** - Clear user sessions & temp data
‚Ä¢ üíæ **Backup Data** - Export critical bot data
‚Ä¢ üîß **Maintenance Mode** - Enable/disable bot maintenance
‚Ä¢ üìà **Performance Test** - Test response times
‚Ä¢ üîÑ **Restart Services** - Restart background processes

‚ö†Ô∏è *Use with caution - some actions may affect active users*`;

  const controlKeyboard = {
    inline_keyboard: [
      [
        { text: "üîÑ Refresh Bot", callback_data: "refresh_bot" },
        { text: "üìä Check Status", callback_data: "bot_status" }
      ],
      [
        { text: "üßπ Clean Cache", callback_data: "clean_cache" },
        { text: "üíæ Backup Data", callback_data: "backup_data" }
      ],
      [
        { text: "üîß Maintenance Mode", callback_data: "toggle_maintenance" },
        { text: "üìà Performance Test", callback_data: "performance_test" }
      ],
      [
        { text: "üîÑ Restart Services", callback_data: "restart_services" },
        { text: "‚ö° Quick Diagnostic", callback_data: "quick_diagnostic" }
      ],
      [
        { text: "üîô Back to Admin", callback_data: "admin_dashboard" }
      ]
    ]
  };

  await sendMessage(chatId, controlMessage, controlKeyboard);
}

async function handleBotStatus(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  console.log(`üìä Bot status check requested by: ${userId}`);

  try {
    // Test database connectivity
    const dbStart = Date.now();
    const dbTest = await supabaseAdmin.from('bot_users').select('count', { count: 'exact' }).limit(1);
    const dbTime = Date.now() - dbStart;

    // Test Telegram API
    const tgStart = Date.now();
    const tgTest = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getMe`);
    const tgTime = Date.now() - tgStart;

    // Get system info
    const uptime = Math.floor((Date.now() - BOT_START_TIME.getTime()) / 1000);
    const hours = Math.floor(uptime / 3600);
    const minutes = Math.floor((uptime % 3600) / 60);
    const seconds = uptime % 60;

    // Get memory usage (simplified)
    const memoryInfo = `Memory usage tracking available`;

    const statusMessage = `üìä *Bot Status Report*

üïê *Uptime:* ${hours}h ${minutes}m ${seconds}s
üìÖ *Started:* ${BOT_START_TIME.toLocaleString()}

üîå *Connectivity:*
‚Ä¢ üóÑÔ∏è Database: ${dbTest.error ? 'üî¥ ERROR' : 'üü¢ OK'} (${dbTime}ms)
‚Ä¢ üì± Telegram API: ${tgTest.ok ? 'üü¢ OK' : 'üî¥ ERROR'} (${tgTime}ms)

‚öôÔ∏è *Configuration:*
‚Ä¢ üîë Admin IDs: ${ADMIN_USER_IDS.size} loaded
‚Ä¢ üí¨ Active Sessions: ${userSessions.size}
‚Ä¢ üåê Environment: ${Deno.env.get("DENO_DEPLOYMENT_ID") ? 'Production' : 'Development'}

üìà *Performance:*
‚Ä¢ üóÑÔ∏è DB Response: ${dbTime < 100 ? 'üü¢ Fast' : dbTime < 500 ? 'üü° Moderate' : 'üî¥ Slow'} (${dbTime}ms)
‚Ä¢ üì± API Response: ${tgTime < 100 ? 'üü¢ Fast' : tgTime < 500 ? 'üü° Moderate' : 'üî¥ Slow'} (${tgTime}ms)
‚Ä¢ üíæ ${memoryInfo}

${dbTest.error ? `‚ùå DB Error: ${dbTest.error.message}` : ''}
${!tgTest.ok ? '‚ùå Telegram API Error' : ''}`;

    const statusKeyboard = {
      inline_keyboard: [
        [
          { text: "üîÑ Refresh Status", callback_data: "bot_status" },
          { text: "üßπ Clean Sessions", callback_data: "clean_cache" }
        ],
        [
          { text: "üìà Performance Test", callback_data: "performance_test" },
          { text: "üîß Diagnostic", callback_data: "quick_diagnostic" }
        ],
        [
          { text: "üîô Back to Control", callback_data: "bot_control" }
        ]
      ]
    };

    await sendMessage(chatId, statusMessage, statusKeyboard);
  } catch (error) {
    console.error('üö® Error in bot status check:', error);
    await sendMessage(chatId, `‚ùå Error checking bot status: ${error.message}`);
  }
}

async function handleRefreshBot(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  console.log(`üîÑ Bot refresh initiated by: ${userId}`);
  await sendMessage(chatId, "üîÑ *Refreshing bot...*\n\nPlease wait while I reload configurations...");

  try {
    // Refresh admin IDs
    await refreshAdminIds();

    // Clear user sessions cache
    userSessions.clear();

    // Test database connectivity
    const dbTest = await supabaseAdmin.from('bot_users').select('count', { count: 'exact' }).limit(1);

    const refreshMessage = `‚úÖ *Bot Refresh Complete!*

üîÑ *Actions Performed:*
‚Ä¢ üîë Reloaded admin IDs (${ADMIN_USER_IDS.size} total)
‚Ä¢ üßπ Cleared user sessions cache
‚Ä¢ üóÑÔ∏è Database connectivity: ${dbTest.error ? 'üî¥ ERROR' : 'üü¢ OK'}
‚Ä¢ ‚öôÔ∏è Revalidated configurations

üïê *Completed at:* ${new Date().toLocaleString()}

‚úÖ Bot is now running with fresh configurations!`;

    await sendMessage(chatId, refreshMessage);
    await logAdminAction(userId, 'bot_refresh', 'Bot refresh completed successfully');
  } catch (error) {
    console.error('üö® Error during bot refresh:', error);
    await sendMessage(chatId, `‚ùå Error during refresh: ${error.message}`);
  }
}

// Broadcasting Functions
async function handleBroadcastMenu(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const broadcastMessage = `üì¢ *Broadcast Management*

üöÄ *Available Broadcast Options:*
‚Ä¢ üëã **Send Greeting** - Send hello message to channels/groups
‚Ä¢ üéØ **Channel Introduction** - Introduce bot to new channels
‚Ä¢ üìù **Custom Broadcast** - Send custom message to all channels
‚Ä¢ üìä **Broadcast History** - View previous broadcasts
‚Ä¢ ‚öôÔ∏è **Broadcast Settings** - Configure broadcast preferences

üí° *Tips:*
‚Ä¢ Test messages in a small group first
‚Ä¢ Use markdown formatting for better appearance
‚Ä¢ Schedule broadcasts for optimal timing`;

  const broadcastKeyboard = {
    inline_keyboard: [
      [
        { text: "üëã Send Greeting", callback_data: "send_greeting" },
        { text: "üéØ Channel Intro", callback_data: "send_channel_intro" }
      ],
      [
        { text: "üìù Custom Broadcast", callback_data: "custom_broadcast" },
        { text: "üìä History", callback_data: "broadcast_history" }
      ],
      [
        { text: "‚öôÔ∏è Settings", callback_data: "broadcast_settings" },
        { text: "üß™ Test Message", callback_data: "test_broadcast" }
      ],
      [
        { text: "üîô Back to Admin", callback_data: "admin_dashboard" }
      ]
    ]
  };

  await sendMessage(chatId, broadcastMessage, broadcastKeyboard);
}

async function handleSendGreeting(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const greetingMessage = await getBotContent('broadcast_greeting') || `üëã *Hello Everyone!*

üéâ **Welcome to Dynamic Capital VIP!**

I'm your new trading assistant bot, here to help you:

üîî **Stay Updated:**
‚Ä¢ Real-time market alerts
‚Ä¢ Trading signals and insights
‚Ä¢ Educational content delivery

üí∞ **Maximize Profits:**
‚Ä¢ VIP package access
‚Ä¢ Exclusive trading strategies
‚Ä¢ Direct mentor support

üöÄ **Get Started:**
‚Ä¢ Use /start to access the main menu
‚Ä¢ Explore our VIP packages
‚Ä¢ Join our community discussions

Looking forward to helping you succeed in trading! üìà

*Powered by Dynamic Capital Team* üíé`;

  // Get channels to broadcast to
  const channels = await getBroadcastChannels();
  
  if (channels.length === 0) {
    await sendMessage(chatId, "‚ö†Ô∏è No broadcast channels configured. Please add channel IDs to broadcast settings first.");
    return;
  }

  await sendMessage(chatId, `üì¢ *Sending Greeting Message*\n\nüì° Broadcasting to ${channels.length} channels...\n\n*Message Preview:*\n${greetingMessage.substring(0, 200)}...`);

  let successCount = 0;
  let failCount = 0;

  for (const channelId of channels) {
    try {
      await sendMessage(parseInt(channelId), greetingMessage);
      successCount++;
      console.log(`‚úÖ Greeting sent to channel: ${channelId}`);
    } catch (error) {
      failCount++;
      console.error(`‚ùå Failed to send greeting to channel ${channelId}:`, error);
    }
    
    // Small delay between messages to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  const resultMessage = `üì¢ *Greeting Broadcast Complete!*

‚úÖ **Successfully sent:** ${successCount} channels
‚ùå **Failed:** ${failCount} channels
üìä **Total channels:** ${channels.length}

${failCount > 0 ? '‚ö†Ô∏è Check logs for failed channels and verify permissions.' : 'üéâ All messages sent successfully!'}`;

  await sendMessage(chatId, resultMessage);
  await logAdminAction(userId, 'broadcast_greeting', `Sent greeting to ${successCount}/${channels.length} channels`);
}

async function handleSendChannelIntro(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const introMessage = await getBotContent('broadcast_intro') || `ü§ñ *Bot Introduction*

üì¢ **Dynamic Capital VIP Bot is now LIVE!**

üéØ **What I can do for you:**

üíé **VIP Services:**
‚Ä¢ Show available membership packages
‚Ä¢ Process subscription requests  
‚Ä¢ Provide member support

üéì **Education Hub:**
‚Ä¢ Access trading courses
‚Ä¢ View learning materials
‚Ä¢ Track your progress

üìä **Market Intelligence:**
‚Ä¢ Real-time trading signals
‚Ä¢ Market analysis updates
‚Ä¢ Price alerts & notifications

üõü **24/7 Support:**
‚Ä¢ Answer frequently asked questions
‚Ä¢ Connect you with support team
‚Ä¢ Resolve account issues

**üöÄ Get Started Now:**
Send me /start to explore all features!

*Ready to transform your trading journey?* üí∞üìà`;

  const channels = await getBroadcastChannels();
  
  if (channels.length === 0) {
    await sendMessage(chatId, "‚ö†Ô∏è No broadcast channels configured. Please add channel IDs to broadcast settings first.");
    return;
  }

  await sendMessage(chatId, `üéØ *Sending Introduction Message*\n\nüì° Broadcasting to ${channels.length} channels...\n\n*Message Preview:*\n${introMessage.substring(0, 200)}...`);

  let successCount = 0;
  let failCount = 0;

  for (const channelId of channels) {
    try {
      await sendMessage(parseInt(channelId), introMessage);
      successCount++;
      console.log(`‚úÖ Introduction sent to channel: ${channelId}`);
    } catch (error) {
      failCount++;
      console.error(`‚ùå Failed to send introduction to channel ${channelId}:`, error);
    }
    
    // Small delay between messages
    await new Promise(resolve => setTimeout(resolve, 1500));
  }

  const resultMessage = `üéØ *Introduction Broadcast Complete!*

‚úÖ **Successfully sent:** ${successCount} channels
‚ùå **Failed:** ${failCount} channels
üìä **Total channels:** ${channels.length}

${failCount > 0 ? '‚ö†Ô∏è Some messages failed to send. Check bot permissions in those channels.' : 'üéâ All introductions sent successfully!'}`;

  await sendMessage(chatId, resultMessage);
  await logAdminAction(userId, 'broadcast_intro', `Sent introduction to ${successCount}/${channels.length} channels`);
}

async function handleCustomBroadcast(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const userSession = getUserSession(userId);
  userSession.awaitingInput = 'custom_broadcast_message';

  await sendMessage(chatId, `üìù *Custom Broadcast*

üìã **Instructions:**
‚Ä¢ Send me the message you want to broadcast
‚Ä¢ Use Markdown formatting for better appearance
‚Ä¢ Include emojis and formatting as needed
‚Ä¢ Message will be sent to all configured channels

üí° **Formatting Tips:**
‚Ä¢ Use *bold* for emphasis
‚Ä¢ Use _italic_ for subtle text
‚Ä¢ Use \`code\` for highlights
‚Ä¢ Use [links](url) for references

üì§ **Send your message now:**`);
}

async function handleNewChatMember(message: any): Promise<void> {
  const chatId = message.chat.id;
  const chatTitle = message.chat.title || 'Unknown Chat';
  const newMembers = message.new_chat_members || [];

  console.log(`üë• New member(s) added to ${chatTitle} (${chatId})`);

  // Check if the bot itself was added
  const botMember = newMembers.find((member: any) => member.username === 'Dynamic_VIP_BOT' || member.is_bot);
  
  if (botMember) {
    console.log(`ü§ñ Bot was added to new chat: ${chatTitle}`);
    
    // Send automatic introduction when bot is added to new channel/group
    const autoIntroMessage = await getBotContent('auto_intro') || `üëã *Hello ${chatTitle}!*

ü§ñ **Dynamic Capital VIP Bot** is now active here!

üöÄ **I'm here to help with:**
‚Ä¢ üíé VIP membership packages
‚Ä¢ üéì Trading education resources  
‚Ä¢ üìä Market updates & signals
‚Ä¢ üõü 24/7 customer support

**üéØ Get started with /start**

*Thank you for adding me to your community!* üôè`;

    // Wait a moment before sending intro (looks more natural)
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    try {
      await sendMessage(chatId, autoIntroMessage);
      console.log(`‚úÖ Auto introduction sent to: ${chatTitle}`);
      
      // Log the new channel addition
      await supabaseAdmin
        .from('admin_logs')
        .insert({
          admin_telegram_id: 'system',
          action_type: 'bot_added_to_chat',
          action_description: `Bot added to: ${chatTitle} (${chatId})`,
          new_values: { chat_id: chatId, chat_title: chatTitle, chat_type: message.chat.type }
        });
        
    } catch (error) {
      console.error(`‚ùå Failed to send auto intro to ${chatTitle}:`, error);
    }
  }
}

// Function to handle custom broadcast sending
async function handleCustomBroadcastSend(chatId: number, userId: string, message: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  // Clear awaiting input
  const userSession = getUserSession(userId);
  userSession.awaitingInput = null;

  if (!message || message.trim().length === 0) {
    await sendMessage(chatId, "‚ùå Empty message. Please try again with /broadcast");
    return;
  }

  const channels = await getBroadcastChannels();
  
  if (channels.length === 0) {
    await sendMessage(chatId, "‚ö†Ô∏è No broadcast channels configured. Please add channel IDs to broadcast settings first.");
    return;
  }

  // Show preview and confirm
  const previewMessage = `üìù *Custom Broadcast Preview*

üì° **Broadcasting to:** ${channels.length} channels
üìù **Message:**

${message}

üîÑ **Broadcasting now...**`;

  await sendMessage(chatId, previewMessage);

  let successCount = 0;
  let failCount = 0;

  for (const channelId of channels) {
    try {
      await sendMessage(parseInt(channelId), message);
      successCount++;
      console.log(`‚úÖ Custom broadcast sent to channel: ${channelId}`);
    } catch (error) {
      failCount++;
      console.error(`‚ùå Failed to send broadcast to channel ${channelId}:`, error);
    }
    
    // Delay between messages
    const delay = parseInt(await getBotSetting('broadcast_delay_ms') || '1500');
    await new Promise(resolve => setTimeout(resolve, delay));
  }

  const resultMessage = `üìù *Custom Broadcast Complete!*

‚úÖ **Successfully sent:** ${successCount} channels
‚ùå **Failed:** ${failCount} channels
üìä **Total channels:** ${channels.length}

${failCount > 0 ? '‚ö†Ô∏è Some messages failed. Check bot permissions in those channels.' : 'üéâ All messages sent successfully!'}`;

  await sendMessage(chatId, resultMessage);
  await logAdminAction(userId, 'custom_broadcast', `Sent custom message to ${successCount}/${channels.length} channels`);
}

// Additional broadcast helper functions
async function handleBroadcastHistory(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const historyMessage = `üìä *Broadcast History*

üìà **Recent Activity:**
‚Ä¢ Last greeting broadcast: Not tracked yet
‚Ä¢ Last introduction: Not tracked yet  
‚Ä¢ Custom broadcasts: 0 sent

üìã **Statistics:**
‚Ä¢ Total broadcasts this month: 0
‚Ä¢ Success rate: N/A
‚Ä¢ Most active channel: N/A

üîß **To enable detailed tracking:**
Run the analytics setup command to start tracking broadcast metrics.

üìù **Note:** History tracking will be available in future updates.`;

  const historyKeyboard = {
    inline_keyboard: [
      [
        { text: "üîÑ Refresh", callback_data: "broadcast_history" },
        { text: "üìä Full Analytics", callback_data: "admin_analytics" }
      ],
      [
        { text: "üîô Back to Broadcast", callback_data: "admin_broadcast" }
      ]
    ]
  };

  await sendMessage(chatId, historyMessage, historyKeyboard);
}

async function handleBroadcastSettings(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const currentChannels = await getBroadcastChannels();
  const autoIntro = await getBotSetting('auto_intro_enabled') || 'true';
  const delay = await getBotSetting('broadcast_delay_ms') || '1500';

  const settingsMessage = `‚öôÔ∏è *Broadcast Settings*

üì° **Configured Channels:** ${currentChannels.length}
${currentChannels.length > 0 ? '‚Ä¢ ' + currentChannels.join('\n‚Ä¢ ') : '‚Ä¢ No channels configured'}

ü§ñ **Auto Introduction:** ${autoIntro === 'true' ? '‚úÖ Enabled' : '‚ùå Disabled'}
‚è±Ô∏è **Message Delay:** ${delay}ms

üìù **To modify settings:**
Use the admin settings panel or contact support.

üí° **Tips:**
‚Ä¢ Get channel IDs using @userinfobot
‚Ä¢ Test with small groups first
‚Ä¢ Ensure bot has admin rights in channels`;

  const settingsKeyboard = {
    inline_keyboard: [
      [
        { text: "üìù Edit Channels", callback_data: "edit_channels" },
        { text: "üîß Auto Settings", callback_data: "auto_settings" }
      ],
      [
        { text: "üß™ Test Setup", callback_data: "test_broadcast" },
        { text: "üí° Help Guide", callback_data: "broadcast_help" }
      ],
      [
        { text: "üîô Back to Broadcast", callback_data: "admin_broadcast" }
      ]
    ]
  };

  await sendMessage(chatId, settingsMessage, settingsKeyboard);
}

async function handleTestBroadcast(chatId: number, userId: string): Promise<void> {
  if (!isAdmin(userId)) {
    await sendMessage(chatId, "‚ùå Access denied.");
    return;
  }

  const testMessage = "üß™ **Test Broadcast**\n\nThis is a test message from Dynamic Capital VIP Bot.\nIf you're seeing this, broadcasting is working correctly! ‚úÖ";
  
  // For testing, send to the admin chat first
  await sendMessage(chatId, `üß™ *Test Broadcast*

üìù **Test Message:**
${testMessage}

üîß **Test sent to your chat first.**
If this works, you can proceed with broadcasting to channels.

‚ö†Ô∏è **Before broadcasting to channels:**
‚Ä¢ Ensure bot has proper permissions
‚Ä¢ Verify channel IDs are correct
‚Ä¢ Test with one channel first`);

  await logAdminAction(userId, 'test_broadcast', 'Executed broadcast test');
}

async function getBroadcastChannels(): Promise<string[]> {
  try {
    const channelsSetting = await getBotSetting('broadcast_channels');
    if (!channelsSetting) {
      return [];
    }
    
    // Parse channels from setting (comma-separated list)
    return channelsSetting.split(',').map(ch => ch.trim()).filter(ch => ch.length > 0);
  } catch (error) {
    console.error('üö® Error getting broadcast channels:', error);
    return [];
  }
}

// Main serve function
serve(async (req) => {
  console.log(`üì• Request received: ${req.method} ${req.url}`);

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  if (req.method === "GET") {
    const uptimeMinutes = Math.floor((Date.now() - BOT_START_TIME.getTime()) / 1000 / 60);
    return new Response(
      `üöÄ Enhanced Dynamic Capital Bot is live!\n\n‚è∞ Uptime: ${uptimeMinutes} minutes\nüîë Admins: ${ADMIN_USER_IDS.size}\nüí¨ Sessions: ${userSessions.size}`, 
      { status: 200, headers: corsHeaders }
    );
  }

  try {
    const body = await req.text();
    const update = JSON.parse(body);

    console.log("üì® Update received:", JSON.stringify(update, null, 2));

    // Extract user info
    const from = update.message?.from || update.callback_query?.from;
    if (!from) {
      console.log("‚ùå No 'from' user found in update");
      return new Response("OK", { status: 200 });
    }

    const chatId = update.message?.chat?.id || update.callback_query?.message?.chat?.id;
    const userId = from.id.toString();
    const firstName = from.first_name || 'Friend';
    const lastName = from.last_name;
    const username = from.username;

    console.log(`üë§ Processing update for user: ${userId} (${firstName})`);

    // Track user activity for session management (using updateBotSession instead)
    await updateBotSession(userId, {
      message_type: update.message ? 'message' : 'callback_query',
      text: update.message?.text || update.callback_query?.data,
      timestamp: new Date().toISOString()
    });

    // Handle regular messages
    if (update.message) {
      const text = update.message.text;
      console.log(`üìù Processing text message: ${text} from user: ${userId}`);

      // Update session activity
      await updateBotSession(userId, {
        message_type: 'text',
        text: text,
        timestamp: new Date().toISOString()
      });

      // Check for maintenance mode
      const maintenanceMode = await getBotSetting('maintenance_mode');
      if (maintenanceMode === 'true' && !isAdmin(userId)) {
        console.log("üîß Bot in maintenance mode for non-admin user");
        await sendMessage(chatId, "üîß *Bot is under maintenance*\n\n‚è∞ We'll be back soon! Thank you for your patience.\n\nüõü For urgent support, contact @DynamicCapital_Support");
        return new Response("OK", { status: 200 });
      }

      // Handle /start command with dynamic welcome message
      if (text === '/start') {
        console.log(`üöÄ Start command from: ${userId} (${firstName})`);
        await startBotSession(userId, { firstName, username, command: 'start' });
        
        const autoReply = await getAutoReply('auto_reply_welcome', { firstName });
        const welcomeMessage = autoReply || await getWelcomeMessage(firstName);
        const keyboard = await getMainMenuKeyboard();
        await sendMessage(chatId, welcomeMessage, keyboard);
        return new Response("OK", { status: 200 });
      }

      // Handle /admin command
      if (text === '/admin') {
        console.log(`üîê Admin command from: ${userId} (${firstName})`);
        console.log(`üîê Admin check result: ${isAdmin(userId)}`);
        console.log(`üîê Current admin IDs: ${Array.from(ADMIN_USER_IDS).join(', ')}`);
        
        if (isAdmin(userId)) {
          await handleAdminDashboard(chatId, userId);
        } else {
          await sendMessage(chatId, "‚ùå Access denied. Admin privileges required.\n\nüîë Your ID: `" + userId + "`\nüõü Contact support if you should have admin access.");
        }
        return new Response("OK", { status: 200 });
      }

      // Handle /help command
      if (text === '/help') {
        await handleHelpCommand(chatId, userId, firstName);
        return new Response("OK", { status: 200 });
      }

      // Handle /status command for admins
      if (text === '/status' && isAdmin(userId)) {
        await handleBotStatus(chatId, userId);
        return new Response("OK", { status: 200 });
      }

      // Handle /refresh command for admins
      if (text === '/refresh' && isAdmin(userId)) {
        await handleRefreshBot(chatId, userId);
        return new Response("OK", { status: 200 });
      }

      // Check if user is sending custom broadcast message
      const userSession = getUserSession(userId);
      if (userSession.awaitingInput === 'custom_broadcast_message') {
        await handleCustomBroadcastSend(chatId, userId, text);
        return new Response("OK", { status: 200 });
      }

      // Handle /broadcast command for admins
      if (text === '/broadcast' && isAdmin(userId)) {
        await handleBroadcastMenu(chatId, userId);
        return new Response("OK", { status: 200 });
      }

      // Handle new chat member events (when bot is added to channels/groups)
      if (update.message.new_chat_members) {
        await handleNewChatMember(update.message);
        return new Response("OK", { status: 200 });
      }

      // Handle unknown commands with auto-reply
      if (text?.startsWith('/')) {
        await handleUnknownCommand(chatId, userId, text);
        return new Response("OK", { status: 200 });
      }

      // Handle other messages with auto-reply
      const generalReply = await getAutoReply('auto_reply_general') || 
        "ü§ñ Thanks for your message! Use /start to see the main menu or /help for assistance.";
      await sendMessage(chatId, generalReply);
    }

    // Handle callback queries
    if (update.callback_query) {
      const callbackData = update.callback_query.data;
      console.log(`üîò Processing callback: ${callbackData} from user: ${userId}`);

      // Update session activity
      await updateBotSession(userId, {
        message_type: 'callback',
        callback_data: callbackData,
        timestamp: new Date().toISOString()
      });

      try {
        switch (callbackData) {
          case 'view_vip_packages':
            console.log("üíé Displaying VIP packages");
            const vipMessage = await getFormattedVipPackages();
            const vipKeyboard = await getVipPackagesKeyboard();
            await sendMessage(chatId, vipMessage, vipKeyboard);
            break;

          case 'back_main':
            const autoReply = await getAutoReply('auto_reply_welcome', { firstName });
            const mainMessage = autoReply || await getWelcomeMessage(firstName);
            const mainKeyboard = await getMainMenuKeyboard();
            await sendMessage(chatId, mainMessage, mainKeyboard);
            break;

          case 'admin_dashboard':
            console.log(`üîê Admin dashboard callback from: ${userId}`);
            await handleAdminDashboard(chatId, userId);
            break;

          case 'bot_control':
            await handleBotControl(chatId, userId);
            break;

          case 'bot_status':
            await handleBotStatus(chatId, userId);
            break;

          case 'refresh_bot':
            await handleRefreshBot(chatId, userId);
            break;

          case 'view_sessions':
            await handleViewSessions(chatId, userId);
            break;

          case 'clean_cache':
            if (isAdmin(userId)) {
              userSessions.clear();
              await sendMessage(chatId, "üßπ *Cache Cleaned!*\n\n‚úÖ All user sessions cleared\n‚úÖ Temporary data removed");
              await logAdminAction(userId, 'cache_clean', 'User sessions cache cleared');
            }
            break;

          case 'clean_old_sessions':
            if (isAdmin(userId)) {
              try {
                // End sessions older than 24 hours
                const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
                const { data, error } = await supabaseAdmin
                  .from('bot_sessions')
                  .update({ 
                    session_end: new Date().toISOString(),
                    duration_minutes: 1440 // 24 hours max
                  })
                  .is('session_end', null)
                  .lt('session_start', cutoffTime)
                  .select('count', { count: 'exact' });

                await sendMessage(chatId, `üßπ *Old Sessions Cleaned!*\n\n‚úÖ Cleaned ${data?.length || 0} old sessions\nüïê Sessions older than 24h ended`);
                await logAdminAction(userId, 'session_cleanup', `Cleaned ${data?.length || 0} old sessions`);
              } catch (error) {
                await sendMessage(chatId, `‚ùå Error cleaning sessions: ${error.message}`);
              }
            }
            break;

          case 'quick_diagnostic':
            if (isAdmin(userId)) {
              const diagnostic = `üîß *Quick Diagnostic*

üîë **Environment:**
‚Ä¢ Bot Token: ${BOT_TOKEN ? '‚úÖ' : '‚ùå'}
‚Ä¢ Database: ${SUPABASE_URL ? '‚úÖ' : '‚ùå'}
‚Ä¢ Service Key: ${SUPABASE_SERVICE_ROLE_KEY ? '‚úÖ' : '‚ùå'}

üìä **Current State:**
‚Ä¢ Admin Count: ${ADMIN_USER_IDS.size}
‚Ä¢ Memory Sessions: ${userSessions.size}
‚Ä¢ Active Bot Sessions: ${activeBotSessions.size}
‚Ä¢ Uptime: ${Math.floor((Date.now() - BOT_START_TIME.getTime()) / 1000 / 60)}min

ü§ñ **Bot Info:**
‚Ä¢ Started: ${BOT_START_TIME.toLocaleString()}
‚Ä¢ Function ID: telegram-bot
‚Ä¢ Status: üü¢ Running`;

              await sendMessage(chatId, diagnostic);
            }
            break;

          case 'admin_broadcast':
            await handleBroadcastMenu(chatId, userId);
            break;

          case 'send_greeting':
            await handleSendGreeting(chatId, userId);
            break;

          case 'send_channel_intro':
            await handleSendChannelIntro(chatId, userId);
            break;

          case 'custom_broadcast':
            await handleCustomBroadcast(chatId, userId);
            break;

          case 'broadcast_history':
            await handleBroadcastHistory(chatId, userId);
            break;

          case 'broadcast_settings':
            await handleBroadcastSettings(chatId, userId);
            break;

          case 'test_broadcast':
            await handleTestBroadcast(chatId, userId);
            break;

          default:
            console.log(`‚ùì Unknown callback: ${callbackData}`);
            await sendMessage(chatId, "‚ùì Unknown action. Please try again or use /start for the main menu.");
        }

        // Answer callback query to remove loading state
        await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/answerCallbackQuery`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callback_query_id: update.callback_query.id })
        });

      } catch (error) {
        console.error('üö® Error handling callback:', error);
        await sendMessage(chatId, "‚ùå An error occurred. Please try again or contact support.");
        
        // Still answer the callback query
        await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/answerCallbackQuery`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            callback_query_id: update.callback_query.id,
            text: "Error occurred, please try again"
          })
        });
      }
    }

    return new Response("OK", { status: 200 });

  } catch (error) {
    console.error("üö® Main error:", error);
    return new Response("Error", { status: 500, headers: corsHeaders });
  }
});

console.log("üöÄ Bot is ready and listening for updates!");